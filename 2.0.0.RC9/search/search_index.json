{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview SmallRye GraphQL is a library that allows you to easily use GraphQL (both server-side endpoints and client-side code) in your Java-based projects. It implements the MicroProfile GraphQL specification.","title":"Overview"},{"location":"#overview","text":"SmallRye GraphQL is a library that allows you to easily use GraphQL (both server-side endpoints and client-side code) in your Java-based projects. It implements the MicroProfile GraphQL specification.","title":"Overview"},{"location":"client-standalone/","text":"Bootstraping GraphQL clients In general, it is recommended to use SmallRye GraphQL client through the Quarkus extension , or the WildFly feature pack , each of them having their own documentation about how to set up dependencies and bootstrap a client. It is however also possible to use SmallRye GraphQL Client in a standalone application outside any container. The single dependency that you need is io.smallrye:smallrye-graphql-client-implementation-vertx , as the Vert.x based implementation is currently the only supported one. If you're using the client as a script and notice that the JVM doesn't exit even after you close the client instance, it's probably because the client is maintaining a Vertx instance that it created automatically. To solve this issue, you might need to create a Vertx instance on your own, pass it to the client builder, and then close it after closing the client. See the following JBang snippet for an example. Using with JBang This is a full script runnable directly with JBang that uses a dynamic client for connecting to countries.trevorblades.com to obtain a list of countries from its database. ///usr/bin/env jbang \"$0\" \"$@\" ; exit $? //DEPS io.smallrye:smallrye-graphql-client-implementation-vertx:1.5.0 import io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClientBuilder; import io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient; import io.smallrye.graphql.client.Response; import io.smallrye.graphql.client.vertx.dynamic.VertxDynamicGraphQLClientBuilder; import io.vertx.core.Vertx; // Has a multiline string literal, requires Java 15+! class Client { public static void main(String... args) throws Exception { Vertx vertx = Vertx.vertx(); DynamicGraphQLClient client = new VertxDynamicGraphQLClientBuilder() .url(\"https://countries.trevorblades.com\") .vertx(vertx) .build(); try { Response response = client.executeSync(\"\"\" query { countries { name } } \"\"\"); System.out.println(response); } finally { client.close(); vertx.close(); } } } Save this file as client.java and execute with jbang client.java .","title":"Bootstrapping the client"},{"location":"client-standalone/#bootstraping-graphql-clients","text":"In general, it is recommended to use SmallRye GraphQL client through the Quarkus extension , or the WildFly feature pack , each of them having their own documentation about how to set up dependencies and bootstrap a client. It is however also possible to use SmallRye GraphQL Client in a standalone application outside any container. The single dependency that you need is io.smallrye:smallrye-graphql-client-implementation-vertx , as the Vert.x based implementation is currently the only supported one. If you're using the client as a script and notice that the JVM doesn't exit even after you close the client instance, it's probably because the client is maintaining a Vertx instance that it created automatically. To solve this issue, you might need to create a Vertx instance on your own, pass it to the client builder, and then close it after closing the client. See the following JBang snippet for an example.","title":"Bootstraping GraphQL clients"},{"location":"client-standalone/#using-with-jbang","text":"This is a full script runnable directly with JBang that uses a dynamic client for connecting to countries.trevorblades.com to obtain a list of countries from its database. ///usr/bin/env jbang \"$0\" \"$@\" ; exit $? //DEPS io.smallrye:smallrye-graphql-client-implementation-vertx:1.5.0 import io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClientBuilder; import io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient; import io.smallrye.graphql.client.Response; import io.smallrye.graphql.client.vertx.dynamic.VertxDynamicGraphQLClientBuilder; import io.vertx.core.Vertx; // Has a multiline string literal, requires Java 15+! class Client { public static void main(String... args) throws Exception { Vertx vertx = Vertx.vertx(); DynamicGraphQLClient client = new VertxDynamicGraphQLClientBuilder() .url(\"https://countries.trevorblades.com\") .vertx(vertx) .build(); try { Response response = client.executeSync(\"\"\" query { countries { name } } \"\"\"); System.out.println(response); } finally { client.close(); vertx.close(); } } } Save this file as client.java and execute with jbang client.java .","title":"Using with JBang"},{"location":"client_configuration/","text":"Client-side configuration properties Note: if you are using Quarkus, it is recommended to use the quarkus.* property counterparts instead. See Quarkus Documentation for more info. Property Default value Meaning CLIENT_NAME/mp-graphql/url none Denotes URL to connect to CLIENT_NAME/mp-graphql/header/KEY none Adds a HTTP header named KEY to all HTTP requests performed by the client CLIENT_NAME/mp-graphql/subprotocols graphql-ws,graphql-transport-ws Comma-separated list of websocket subprotocols supported by this client. We currently support graphql-ws and graphql-transport-ws . If multiple subprotocols are provided, choosing the actual subprotocol will be subject to negotiation with the server. CLIENT_NAME/mp-graphql/keystore none Path to client's keystore (for example file:/path/to/keystore or classpath:path/to/keystore ) CLIENT_NAME/mp-graphql/keystoreType JKS Keystore type CLIENT_NAME/mp-graphql/keystorePassword none Keystore password CLIENT_NAME/mp-graphql/truststore none Path to client's truststore (for example file:/path/to/truststore or classpath:path/to/truststore ) CLIENT_NAME/mp-graphql/truststoreType JKS Truststore type CLIENT_NAME/mp-graphql/truststorePassword none Truststore password CLIENT_NAME/mp-graphql/proxyHost none Hostname of the proxy to use CLIENT_NAME/mp-graphql/proxyPort none Port of the proxy to use CLIENT_NAME/mp-graphql/proxyUsername none Username for the proxy to use CLIENT_NAME/mp-graphql/proxyPassword none Password for the proxy to use CLIENT_NAME/mp-graphql/maxRedirects 16 Max number of redirects to follow. Set to 0 to disable redirects. CLIENT_NAME/mp-graphql/websocketInitializationTimeout none Maximum time in milliseconds that will be allowed to wait for the server to acknowledge a websocket connection. CLIENT_NAME/mp-graphql/runSingleOperationsOverWebsocket false If true, then queries and mutations will run over the websocket transport rather than pure HTTP. Off by default, because it has higher overhead.","title":"Client-side configuration"},{"location":"client_configuration/#client-side-configuration-properties","text":"Note: if you are using Quarkus, it is recommended to use the quarkus.* property counterparts instead. See Quarkus Documentation for more info. Property Default value Meaning CLIENT_NAME/mp-graphql/url none Denotes URL to connect to CLIENT_NAME/mp-graphql/header/KEY none Adds a HTTP header named KEY to all HTTP requests performed by the client CLIENT_NAME/mp-graphql/subprotocols graphql-ws,graphql-transport-ws Comma-separated list of websocket subprotocols supported by this client. We currently support graphql-ws and graphql-transport-ws . If multiple subprotocols are provided, choosing the actual subprotocol will be subject to negotiation with the server. CLIENT_NAME/mp-graphql/keystore none Path to client's keystore (for example file:/path/to/keystore or classpath:path/to/keystore ) CLIENT_NAME/mp-graphql/keystoreType JKS Keystore type CLIENT_NAME/mp-graphql/keystorePassword none Keystore password CLIENT_NAME/mp-graphql/truststore none Path to client's truststore (for example file:/path/to/truststore or classpath:path/to/truststore ) CLIENT_NAME/mp-graphql/truststoreType JKS Truststore type CLIENT_NAME/mp-graphql/truststorePassword none Truststore password CLIENT_NAME/mp-graphql/proxyHost none Hostname of the proxy to use CLIENT_NAME/mp-graphql/proxyPort none Port of the proxy to use CLIENT_NAME/mp-graphql/proxyUsername none Username for the proxy to use CLIENT_NAME/mp-graphql/proxyPassword none Password for the proxy to use CLIENT_NAME/mp-graphql/maxRedirects 16 Max number of redirects to follow. Set to 0 to disable redirects. CLIENT_NAME/mp-graphql/websocketInitializationTimeout none Maximum time in milliseconds that will be allowed to wait for the server to acknowledge a websocket connection. CLIENT_NAME/mp-graphql/runSingleOperationsOverWebsocket false If true, then queries and mutations will run over the websocket transport rather than pure HTTP. Off by default, because it has higher overhead.","title":"Client-side configuration properties"},{"location":"custom-error-extensions/","text":"GraphQL Error Extensions Exceptions are reported in GraphQL in the errors array, next to the data field, so it's possible to return partial results, e.g.: { \"data\" : { \"superHero\" : { \"name\" : \"Wolverine\" , \"location\" : null } }, \"errors\" : [{ \"message\" : \"location unknown\" , \"path\" : [ \"superHero\" , \"location\" ], \"extensions\" :{ \"code\" : \"location-unknown\" } }] } The location field couldn't be returned, and in the errors , there's the reason with a few predefined fields, and a map of extensions that can contain custom details about the error. You can add your own extensions by implementing the io.smallrye.graphql.api.ErrorExtensionProvider interface and adding your class name to a file META-INF/services/io.smallrye.graphql.api.ErrorExtensionProvider (this is a ServiceLoader ). As an example, this class provides an extension named exception-length with the length of the simple class name of the exception: public class ExceptionLengthErrorExtensionProvider implements ErrorExtensionProvider { @Override public String getKey () { return \"exception-length\" ; } @Override public JsonNumber mapValueFrom ( Throwable exception ) { return Json . createValue ( exception . getClass (). getSimpleName (). length ()); } }","title":"Custom error extensions"},{"location":"custom-error-extensions/#graphql-error-extensions","text":"Exceptions are reported in GraphQL in the errors array, next to the data field, so it's possible to return partial results, e.g.: { \"data\" : { \"superHero\" : { \"name\" : \"Wolverine\" , \"location\" : null } }, \"errors\" : [{ \"message\" : \"location unknown\" , \"path\" : [ \"superHero\" , \"location\" ], \"extensions\" :{ \"code\" : \"location-unknown\" } }] } The location field couldn't be returned, and in the errors , there's the reason with a few predefined fields, and a map of extensions that can contain custom details about the error. You can add your own extensions by implementing the io.smallrye.graphql.api.ErrorExtensionProvider interface and adding your class name to a file META-INF/services/io.smallrye.graphql.api.ErrorExtensionProvider (this is a ServiceLoader ). As an example, this class provides an extension named exception-length with the length of the simple class name of the exception: public class ExceptionLengthErrorExtensionProvider implements ErrorExtensionProvider { @Override public String getKey () { return \"exception-length\" ; } @Override public JsonNumber mapValueFrom ( Throwable exception ) { return Json . createValue ( exception . getClass (). getSimpleName (). length ()); } }","title":"GraphQL Error Extensions"},{"location":"custom-json-deserializers/","text":"Customizing JSON-B deserializers If your application needs finer-grained control over JSON deserialization than you can achieve via formatting annotations like @JsonbDateFormat , you may plug in your own custom instances of the Jsonb class for each input type that your GraphQL application exposes. To do this, you'll need to create an implementation of io.smallrye.graphql.spi.EventingService and implement its overrideJsonbConfig method. An example that plugs in a custom date format for a particular class that is used as input: public class CustomJsonbService implements EventingService { @Override public String getConfigKey() { return null; // activate this service always regardless of the configuration } @Override public Map<String, Jsonb> overrideJsonbConfig() { JsonbConfig config = new JsonbConfig().withDateFormat(\"MM dd yyyy HH:mm Z\", null); return Collections.singletonMap(\"org.example.model.MyModelClass\", JsonbBuilder.create(config)); } } As the discovery of eventing services uses the ServiceLoader mechanism, don't forget to add a META-INF/services/io.smallrye.graphql.spi.EventingService file that contains the fully qualified name of your implementation.","title":"Customizing JSON deserializers"},{"location":"custom-json-deserializers/#customizing-json-b-deserializers","text":"If your application needs finer-grained control over JSON deserialization than you can achieve via formatting annotations like @JsonbDateFormat , you may plug in your own custom instances of the Jsonb class for each input type that your GraphQL application exposes. To do this, you'll need to create an implementation of io.smallrye.graphql.spi.EventingService and implement its overrideJsonbConfig method. An example that plugs in a custom date format for a particular class that is used as input: public class CustomJsonbService implements EventingService { @Override public String getConfigKey() { return null; // activate this service always regardless of the configuration } @Override public Map<String, Jsonb> overrideJsonbConfig() { JsonbConfig config = new JsonbConfig().withDateFormat(\"MM dd yyyy HH:mm Z\", null); return Collections.singletonMap(\"org.example.model.MyModelClass\", JsonbBuilder.create(config)); } } As the discovery of eventing services uses the ServiceLoader mechanism, don't forget to add a META-INF/services/io.smallrye.graphql.spi.EventingService file that contains the fully qualified name of your implementation.","title":"Customizing JSON-B deserializers"},{"location":"directives/","text":"Directives Directives generated from Bean Validation annotations If your project uses Bean Validation to validate fields on input types and operation arguments, and you enable inclusion of directives in the schema (by setting smallrye.graphql.schema.includeDirectives=true ), then constraints decoded from annotations will be added to your schema as directives. This is currently only supported for some built-in constraints (annotations from the javax.validation.constraints package), and custom constraints aren't supported at all. Each bean validation annotation is mapped to a single @constraint directive. The directive is declared as repeatable, so if you have multiple constraints on an input field, the field will contain multiple @constraint directives. The following table describes the mapping between BV annotations and @constraint directives (all currently supported BV annotations are listed here): BV annotation GraphQL directive @Size(MIN, MAX) @constraint(minLength=MIN, maxLength=MAX) @Email @constraint(format='email') @Max @constraint(max=VALUE) @Min @constraint(min=VALUE) @Pattern(REGEXP) @constraint(pattern=REGEXP) Note: The @NotNull annotation does not map to a directive, instead it makes the GraphQL type non-nullable. Constraints will only appear on fields of input types and operation arguments.","title":"Directives"},{"location":"directives/#directives","text":"","title":"Directives"},{"location":"directives/#directives-generated-from-bean-validation-annotations","text":"If your project uses Bean Validation to validate fields on input types and operation arguments, and you enable inclusion of directives in the schema (by setting smallrye.graphql.schema.includeDirectives=true ), then constraints decoded from annotations will be added to your schema as directives. This is currently only supported for some built-in constraints (annotations from the javax.validation.constraints package), and custom constraints aren't supported at all. Each bean validation annotation is mapped to a single @constraint directive. The directive is declared as repeatable, so if you have multiple constraints on an input field, the field will contain multiple @constraint directives. The following table describes the mapping between BV annotations and @constraint directives (all currently supported BV annotations are listed here): BV annotation GraphQL directive @Size(MIN, MAX) @constraint(minLength=MIN, maxLength=MAX) @Email @constraint(format='email') @Max @constraint(max=VALUE) @Min @constraint(min=VALUE) @Pattern(REGEXP) @constraint(pattern=REGEXP) Note: The @NotNull annotation does not map to a directive, instead it makes the GraphQL type non-nullable. Constraints will only appear on fields of input types and operation arguments.","title":"Directives generated from Bean Validation annotations"},{"location":"dynamic-client-error-handling/","text":"Error handling with dynamic clients System-level errors If the service returns a system-level error (which means the response body doesn't contain a valid GraphQL response document), the client invocation will (instead of returning a io.smallrye.graphql.client.Response ) throw a io.smallrye.graphql.client.InvalidResponseException whose message contains information about the received status code, status message, and body contents. Application-level errors If the service returns one or more application-level errors (which means that there is valid GraphQL response in the body that has a non-empty errors entry), the client invocation will return a io.smallrye.graphql.client.Response as normal, and that object will contain information about the errors. Errors are represented as io.smallrye.graphql.client.GraphQLError objects and can be inspected after retrieving a list of all errors using response.getErrors() . [NOTE] An error response is considered application-level regardless of the HTTP status code as long as it contains a valid GraphQL response. We define a GraphQL response as a well-formed JSON document that contains at least one of errors , data and extensions entries, and no other entries beyond that. It is also possible to convert a response's errors into a io.smallrye.graphql.client.GraphQLClientException by calling throwExceptionIfErrors() - the response has to be cast to ResponseImpl for this as of now. This method will, if there are any errors in the response, convert the errors into a GraphQLClientException and throw it. If you need to access the HTTP response code and message pertaining to a response that contained application-level errors, refer to Accessing HTTP headers and response codes .","title":"Error handling"},{"location":"dynamic-client-error-handling/#error-handling-with-dynamic-clients","text":"","title":"Error handling with dynamic clients"},{"location":"dynamic-client-error-handling/#system-level-errors","text":"If the service returns a system-level error (which means the response body doesn't contain a valid GraphQL response document), the client invocation will (instead of returning a io.smallrye.graphql.client.Response ) throw a io.smallrye.graphql.client.InvalidResponseException whose message contains information about the received status code, status message, and body contents.","title":"System-level errors"},{"location":"dynamic-client-error-handling/#application-level-errors","text":"If the service returns one or more application-level errors (which means that there is valid GraphQL response in the body that has a non-empty errors entry), the client invocation will return a io.smallrye.graphql.client.Response as normal, and that object will contain information about the errors. Errors are represented as io.smallrye.graphql.client.GraphQLError objects and can be inspected after retrieving a list of all errors using response.getErrors() . [NOTE] An error response is considered application-level regardless of the HTTP status code as long as it contains a valid GraphQL response. We define a GraphQL response as a well-formed JSON document that contains at least one of errors , data and extensions entries, and no other entries beyond that. It is also possible to convert a response's errors into a io.smallrye.graphql.client.GraphQLClientException by calling throwExceptionIfErrors() - the response has to be cast to ResponseImpl for this as of now. This method will, if there are any errors in the response, convert the errors into a GraphQLClientException and throw it. If you need to access the HTTP response code and message pertaining to a response that contained application-level errors, refer to Accessing HTTP headers and response codes .","title":"Application-level errors"},{"location":"dynamic-client-usage/","text":"Dynamic client introduction and basic usage A Java GraphQL client. The main difference from the typesafe client is that while the typesafe client behaves like a typesafe proxy very similar to the MicroProfile REST Client, the dynamic client is more like the JAX-RS client from the jakarta.ws.rs.client package. Instead of working with model classes directly, the dynamic client focuses on programmatically working with GraphQL documents representing GraphQL requests and responses. It still offers the option to convert between documents and model classes when necessary. In the current implementation, Vert.x HTTP client is used for handling the underlying traffic. Creating a client instance Generally there are two ways to obtain a client instance. First, using CDI injection where the configuration values are defined in system properties: @Inject @GraphQLClient ( \"superheroes\" ) DynamicGraphQLClient client ; // assuming that this system property exists: // superheroes/mp-graphql/url=https://superheroes.org/graphql The above example assumes that configuration for the client is present in system properties. For a full list of supported configuration properties, see Client configuration reference The other way to build a client is programmatically using a builder: DynamicGraphQLClient client = DynamicGraphQLClientBuilder . newBuilder () . url ( \"https://superheroes.org/graphql\" ) . build (); The usage examples in the following sections will assume using the first approach - injection. Basic Usage Given the following GraphQL service on the server side: @GraphQLApi class SuperHeroesApi { @Query List < SuperHero > allHeroesIn ( String location ) { // .... } } class SuperHero { private String name ; private List < String > superPowers ; } Such service can be queried this way: package examples.dynamicclient ; import examples.typesafeclient.SuperHero ; import io.smallrye.graphql.client.GraphQLClient ; import io.smallrye.graphql.client.Response ; import io.smallrye.graphql.client.core.Document ; import io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient ; import jakarta.inject.Inject ; import jakarta.json.JsonArray ; import java.util.List ; import java.util.concurrent.ExecutionException ; import static io.smallrye.graphql.client.core.Argument.arg ; import static io.smallrye.graphql.client.core.Argument.args ; import static io.smallrye.graphql.client.core.Document.document ; import static io.smallrye.graphql.client.core.Field.field ; import static io.smallrye.graphql.client.core.Operation.operation ; public class MyClientUsage { @Inject @GraphQLClient ( \"superHeroes\" ) DynamicGraphQLClient client ; public void execute () throws ExecutionException , InterruptedException { Document document = document ( // <1> operation ( field ( \"allHeroesIn\" , args ( arg ( \"location\" , \"Outer Space\" )), field ( \"name\" ), field ( \"superPowers\" )))); Response response = client . executeSync ( document ); // <2> JsonArray heroesArray = response . getData (). getJsonArray ( \"allHeroesIn\" ); // <3> List < SuperHero > heroes = response . getList ( SuperHero . class , \"allHeroesIn\" ); // <4> } } <1> Creating the document representing the request. We used static imports to make the code easy to read, they all come from the classes in the io.smallrye.graphql.client.core package. <2> Executing the request. You can either do that in a blocking way, or request a Uni if you prefer the reactive style. <3> Obtaining the resulting list of heroes as a JsonArray . <4> Obtaining the resulting list of heroes as instances of the model class. This is optional, you can continue working with the data as a JsonArray if you prefer. Using plain strings instead of the DSL If you don't like the DSL for some reason and want to use plain strings for your queries, these two examples will serve you: package examples.dynamicclient ; import io.smallrye.graphql.client.GraphQLClient ; import io.smallrye.graphql.client.Response ; import io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient ; import jakarta.inject.Inject ; import java.util.HashMap ; import java.util.Map ; import java.util.concurrent.ExecutionException ; public class MyClientUsageString { @Inject @GraphQLClient ( \"superheroes\" ) DynamicGraphQLClient client ; public void execute () throws ExecutionException , InterruptedException { String queryWithInlineVariables = // <1> \"query {\" + \" allHeroesIn(location: \\\"Outer Space\\\") {\" + \" name\" + \" superPowers\" + \" }\" + \"}\" ; Response response = client . executeSync ( queryWithInlineVariables ); String queryWithExtractedVariables = // <2> \"query($loc: String) {\" + \" allHeroesIn(location: $loc) {\" + \" name\" + \" superPowers\" + \" }\" + \"}\" ; Map < String , Object > variables = new HashMap <> (); // <3> variables . put ( \"loc\" , \"Outer Space\" ); Response response2 = client . executeSync ( queryWithExtractedVariables , variables ); } } <1>: In this variant, we inline values for query arguments directly into the query string. <2>: In this variant, argument values are extracted into variables. The location argument of the allHeroesIn query is declared to be using the variable loc (the variable can also be named location same as the argument, if you prefer). <3>: Here we create a map that defines the values for each variable. Values of this map are Object s, so you can put in strings, numbers, booleans, or any object that corresponds to a GraphQL type and can be serialized to JSON. Inserting a JsonObject directly is also supported. Accessing HTTP headers and response codes To access HTTP transport metadata that was passed by the server, you can inspect the Response object. Response.getTransportMeta(\"HEADER-NAME\") returns a List<String> containing (potentially multiple) values of the requested header. To get the HTTP status code or status message, these are stored inside the transportMeta map too. ResponseImpl contains convenience methods to retrieve them: ResponseImpl.getStatusCode() and ResponseImpl.getStatusMessage() . It's also possible to retrieve them directly without casting to ResponseImpl by calling Integer.valueOf(response.getTransportMeta().get(\"<status-code>\").get(0)) and response.getTransportMeta().get(\"<status-message>\").get(0) . HTTP headers, status codes and messages are only available for operations executed over pure HTTP, not via websockets!","title":"Basic usage"},{"location":"dynamic-client-usage/#dynamic-client-introduction-and-basic-usage","text":"A Java GraphQL client. The main difference from the typesafe client is that while the typesafe client behaves like a typesafe proxy very similar to the MicroProfile REST Client, the dynamic client is more like the JAX-RS client from the jakarta.ws.rs.client package. Instead of working with model classes directly, the dynamic client focuses on programmatically working with GraphQL documents representing GraphQL requests and responses. It still offers the option to convert between documents and model classes when necessary. In the current implementation, Vert.x HTTP client is used for handling the underlying traffic.","title":"Dynamic client introduction and basic usage"},{"location":"dynamic-client-usage/#creating-a-client-instance","text":"Generally there are two ways to obtain a client instance. First, using CDI injection where the configuration values are defined in system properties: @Inject @GraphQLClient ( \"superheroes\" ) DynamicGraphQLClient client ; // assuming that this system property exists: // superheroes/mp-graphql/url=https://superheroes.org/graphql The above example assumes that configuration for the client is present in system properties. For a full list of supported configuration properties, see Client configuration reference The other way to build a client is programmatically using a builder: DynamicGraphQLClient client = DynamicGraphQLClientBuilder . newBuilder () . url ( \"https://superheroes.org/graphql\" ) . build (); The usage examples in the following sections will assume using the first approach - injection.","title":"Creating a client instance"},{"location":"dynamic-client-usage/#basic-usage","text":"Given the following GraphQL service on the server side: @GraphQLApi class SuperHeroesApi { @Query List < SuperHero > allHeroesIn ( String location ) { // .... } } class SuperHero { private String name ; private List < String > superPowers ; } Such service can be queried this way: package examples.dynamicclient ; import examples.typesafeclient.SuperHero ; import io.smallrye.graphql.client.GraphQLClient ; import io.smallrye.graphql.client.Response ; import io.smallrye.graphql.client.core.Document ; import io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient ; import jakarta.inject.Inject ; import jakarta.json.JsonArray ; import java.util.List ; import java.util.concurrent.ExecutionException ; import static io.smallrye.graphql.client.core.Argument.arg ; import static io.smallrye.graphql.client.core.Argument.args ; import static io.smallrye.graphql.client.core.Document.document ; import static io.smallrye.graphql.client.core.Field.field ; import static io.smallrye.graphql.client.core.Operation.operation ; public class MyClientUsage { @Inject @GraphQLClient ( \"superHeroes\" ) DynamicGraphQLClient client ; public void execute () throws ExecutionException , InterruptedException { Document document = document ( // <1> operation ( field ( \"allHeroesIn\" , args ( arg ( \"location\" , \"Outer Space\" )), field ( \"name\" ), field ( \"superPowers\" )))); Response response = client . executeSync ( document ); // <2> JsonArray heroesArray = response . getData (). getJsonArray ( \"allHeroesIn\" ); // <3> List < SuperHero > heroes = response . getList ( SuperHero . class , \"allHeroesIn\" ); // <4> } } <1> Creating the document representing the request. We used static imports to make the code easy to read, they all come from the classes in the io.smallrye.graphql.client.core package. <2> Executing the request. You can either do that in a blocking way, or request a Uni if you prefer the reactive style. <3> Obtaining the resulting list of heroes as a JsonArray . <4> Obtaining the resulting list of heroes as instances of the model class. This is optional, you can continue working with the data as a JsonArray if you prefer.","title":"Basic Usage"},{"location":"dynamic-client-usage/#using-plain-strings-instead-of-the-dsl","text":"If you don't like the DSL for some reason and want to use plain strings for your queries, these two examples will serve you: package examples.dynamicclient ; import io.smallrye.graphql.client.GraphQLClient ; import io.smallrye.graphql.client.Response ; import io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient ; import jakarta.inject.Inject ; import java.util.HashMap ; import java.util.Map ; import java.util.concurrent.ExecutionException ; public class MyClientUsageString { @Inject @GraphQLClient ( \"superheroes\" ) DynamicGraphQLClient client ; public void execute () throws ExecutionException , InterruptedException { String queryWithInlineVariables = // <1> \"query {\" + \" allHeroesIn(location: \\\"Outer Space\\\") {\" + \" name\" + \" superPowers\" + \" }\" + \"}\" ; Response response = client . executeSync ( queryWithInlineVariables ); String queryWithExtractedVariables = // <2> \"query($loc: String) {\" + \" allHeroesIn(location: $loc) {\" + \" name\" + \" superPowers\" + \" }\" + \"}\" ; Map < String , Object > variables = new HashMap <> (); // <3> variables . put ( \"loc\" , \"Outer Space\" ); Response response2 = client . executeSync ( queryWithExtractedVariables , variables ); } } <1>: In this variant, we inline values for query arguments directly into the query string. <2>: In this variant, argument values are extracted into variables. The location argument of the allHeroesIn query is declared to be using the variable loc (the variable can also be named location same as the argument, if you prefer). <3>: Here we create a map that defines the values for each variable. Values of this map are Object s, so you can put in strings, numbers, booleans, or any object that corresponds to a GraphQL type and can be serialized to JSON. Inserting a JsonObject directly is also supported.","title":"Using plain strings instead of the DSL"},{"location":"dynamic-client-usage/#accessing-http-headers-and-response-codes","text":"To access HTTP transport metadata that was passed by the server, you can inspect the Response object. Response.getTransportMeta(\"HEADER-NAME\") returns a List<String> containing (potentially multiple) values of the requested header. To get the HTTP status code or status message, these are stored inside the transportMeta map too. ResponseImpl contains convenience methods to retrieve them: ResponseImpl.getStatusCode() and ResponseImpl.getStatusMessage() . It's also possible to retrieve them directly without casting to ResponseImpl by calling Integer.valueOf(response.getTransportMeta().get(\"<status-code>\").get(0)) and response.getTransportMeta().get(\"<status-message>\").get(0) . HTTP headers, status codes and messages are only available for operations executed over pure HTTP, not via websockets!","title":"Accessing HTTP headers and response codes"},{"location":"gradle-plugin/","text":"SmallRye GraphQL Gradle plugin This Gradle plugin allows you to generate the GraphQL Schema on build and save it as a text file. Add this to your build.gradle: plugins { id 'io.smallrye.graphql' version '1.0.2-SNAPSHOT' } The schema will appear as build/generated/schema.graphql by default. The plugin\u2019s generateSchema task can customized like: generateSchema { destination = null includeTransitiveDependencies = true includeScalars = true } This will include the project\u2019s dependencies (including the transitive dependencies) to scan for GraphQL model classes. As the destination is set to null the generated schema will only be output to the console and saved to a file. In case external dependencies need to be scanned for GraphQL model classes a more advanced configuration could look like: configrations { graphQLSchema } dependencies { graphQLSchema .. } generateSchema { includeDependencies = true configurations = [\"graphQLSchema\"] } This defines a separate graphQLSchema configuration. In the dependencies block the external dependencies containing the GraphQL mode class should then be registered for the graphQLSchema configuration. The generateSchema task is then customized to only include dependencies from the graphQLSchema configuration. Also note that we set includeDependencies to true (and not includeTransitiveDependencies ). This will make sure only direct dependencies will be be scanned and not possible transitive dependencies. Configuration options destination - To override the default build/generated/schema.graphql destination. includeDependencies - Scan project\u2019s dependencies for GraphQL model classes too. Default false. includeTransitiveDependencies - Scan project\u2019s dependencies (including the transitive dependencies) for GraphQL model classes too. Default false. configurations - If the above includeDependencies or includeTransitiveDependencies is true, you can control what configurations should be included. Default is implementation . dependencyExtensions - If the above includeDependencies or includeTransitiveDependencies is true, you can control what dependency extensions should be included. Default is jar . includeScalars - Include scalars in the schema. Default false. includeDirectives - Include directives in the schema. Default false. includeSchemaDefinition - Include the schema definition. Default false. includeIntrospectionTypes - Include the introspection types in the schema. Default false.","title":"Gradle plugin"},{"location":"gradle-plugin/#smallrye-graphql-gradle-plugin","text":"This Gradle plugin allows you to generate the GraphQL Schema on build and save it as a text file. Add this to your build.gradle: plugins { id 'io.smallrye.graphql' version '1.0.2-SNAPSHOT' } The schema will appear as build/generated/schema.graphql by default. The plugin\u2019s generateSchema task can customized like: generateSchema { destination = null includeTransitiveDependencies = true includeScalars = true } This will include the project\u2019s dependencies (including the transitive dependencies) to scan for GraphQL model classes. As the destination is set to null the generated schema will only be output to the console and saved to a file. In case external dependencies need to be scanned for GraphQL model classes a more advanced configuration could look like: configrations { graphQLSchema } dependencies { graphQLSchema .. } generateSchema { includeDependencies = true configurations = [\"graphQLSchema\"] } This defines a separate graphQLSchema configuration. In the dependencies block the external dependencies containing the GraphQL mode class should then be registered for the graphQLSchema configuration. The generateSchema task is then customized to only include dependencies from the graphQLSchema configuration. Also note that we set includeDependencies to true (and not includeTransitiveDependencies ). This will make sure only direct dependencies will be be scanned and not possible transitive dependencies.","title":"SmallRye GraphQL Gradle plugin"},{"location":"gradle-plugin/#configuration-options","text":"destination - To override the default build/generated/schema.graphql destination. includeDependencies - Scan project\u2019s dependencies for GraphQL model classes too. Default false. includeTransitiveDependencies - Scan project\u2019s dependencies (including the transitive dependencies) for GraphQL model classes too. Default false. configurations - If the above includeDependencies or includeTransitiveDependencies is true, you can control what configurations should be included. Default is implementation . dependencyExtensions - If the above includeDependencies or includeTransitiveDependencies is true, you can control what dependency extensions should be included. Default is jar . includeScalars - Include scalars in the schema. Default false. includeDirectives - Include directives in the schema. Default false. includeSchemaDefinition - Include the schema definition. Default false. includeIntrospectionTypes - Include the introspection types in the schema. Default false.","title":"Configuration options"},{"location":"maven-plugin/","text":"SmallRye GraphQL Maven plugin This Maven plugin allows you to generate the GraphQL Schema on build and save it as a text file. Add this to your pom.xml: <plugin> <artifactId> smallrye-graphql-maven-plugin </artifactId> <groupId> io.smallrye </groupId> <executions> <execution> <goals> <goal> generate-schema </goal> </goals> </execution> </executions> </plugin> The schema will appear as target/generated/schema.graphql by default. The goal is bound to the process-classes build phase. Configuration options destination - To override the default target/generated/schema.graphql destination includeDependencies - Scan project\u2019s dependencies for GraphQL model classes too. This is necessary if your GraphQL endpoint exposes classes that are not in the application's main module. Off ( false ) by default, because scanning a potentially large dependency tree slows down execution substantially. Usage of reactive types does not require turning this option on. includeDependenciesScopes - If the above includeDependencies is true, you can control what scopes should be included. Default is compile, system includeDependenciesTypes - If the above includeDependencies is true, you can control what types should be included. Default is jar includeScalars - Include scalars in the schema. Default false. includeDirectives - Include directives in the schema. Default false. includeSchemaDefinition - Include the schema definition. Default false. includeIntrospectionTypes - Include the introspection types in the schema. Default false. typeAutoNameStrategy - Strategy for transforming class names into GraphQL type names. Valid values are MergeInnerClass , Full and Default .","title":"Maven plugin"},{"location":"maven-plugin/#smallrye-graphql-maven-plugin","text":"This Maven plugin allows you to generate the GraphQL Schema on build and save it as a text file. Add this to your pom.xml: <plugin> <artifactId> smallrye-graphql-maven-plugin </artifactId> <groupId> io.smallrye </groupId> <executions> <execution> <goals> <goal> generate-schema </goal> </goals> </execution> </executions> </plugin> The schema will appear as target/generated/schema.graphql by default. The goal is bound to the process-classes build phase.","title":"SmallRye GraphQL Maven plugin"},{"location":"maven-plugin/#configuration-options","text":"destination - To override the default target/generated/schema.graphql destination includeDependencies - Scan project\u2019s dependencies for GraphQL model classes too. This is necessary if your GraphQL endpoint exposes classes that are not in the application's main module. Off ( false ) by default, because scanning a potentially large dependency tree slows down execution substantially. Usage of reactive types does not require turning this option on. includeDependenciesScopes - If the above includeDependencies is true, you can control what scopes should be included. Default is compile, system includeDependenciesTypes - If the above includeDependencies is true, you can control what types should be included. Default is jar includeScalars - Include scalars in the schema. Default false. includeDirectives - Include directives in the schema. Default false. includeSchemaDefinition - Include the schema definition. Default false. includeIntrospectionTypes - Include the introspection types in the schema. Default false. typeAutoNameStrategy - Strategy for transforming class names into GraphQL type names. Valid values are MergeInnerClass , Full and Default .","title":"Configuration options"},{"location":"server_configuration/","text":"Configuration properties These are properties understood directly by SmallRye GraphQL. If you're using SmallRye GraphQL through Quarkus, these will generally work, but Quarkus offers its own counterparts for most of these, and it is recommended to use the quarkus.* properties. Refer to the Quarkus documentation: Server and Client side Quarkus properties. From MicroProfile GraphQL Property Default value Meaning mp.graphql.defaultErrorMessage Server Error Error message for hidden exceptions mp.graphql.hideErrorMessage Runtime exceptions Exceptions that will be hidden mp.graphql.showErrorMessage Checked exceptions Exceptions that will not be hidden. From SmallRye GraphQL Property Default value Meaning smallrye.graphql.printDataFetcherException false Include the stacktrace of the data fetching exception in the log output smallrye.graphql.allowGet false Allow HTTP GET Method smallrye.graphql.metrics.enabled false Enable metrics smallrye.graphql.tracing.enabled false Enable tracing smallrye.graphql.validation.enabled true if Bean Validation is present Enable Bean Validation. This property is DEPRECATED, setting to false won't actually turn off validation. It will be removed in a future release. smallrye.graphql.events.enabled true if one of metrics, tracing or bean validation is true Enable eventing smallrye.graphql.logPayload false Log the payload in the log file smallrye.graphql.fieldVisibility To control the field visibility on introspection smallrye.graphql.schema.includeScalars true Include Scalar definitions in the schema smallrye.graphql.schema.includeSchemaDefinition false Include Schema definition smallrye.graphql.schema.includeDirectives false Include directives in the schema smallrye.graphql.schema.includeIntrospectionTypes false Include Introspection types in the schema","title":"Server-side configuration"},{"location":"server_configuration/#configuration-properties","text":"These are properties understood directly by SmallRye GraphQL. If you're using SmallRye GraphQL through Quarkus, these will generally work, but Quarkus offers its own counterparts for most of these, and it is recommended to use the quarkus.* properties. Refer to the Quarkus documentation: Server and Client side Quarkus properties.","title":"Configuration properties"},{"location":"server_configuration/#from-microprofile-graphql","text":"Property Default value Meaning mp.graphql.defaultErrorMessage Server Error Error message for hidden exceptions mp.graphql.hideErrorMessage Runtime exceptions Exceptions that will be hidden mp.graphql.showErrorMessage Checked exceptions Exceptions that will not be hidden.","title":"From MicroProfile GraphQL"},{"location":"server_configuration/#from-smallrye-graphql","text":"Property Default value Meaning smallrye.graphql.printDataFetcherException false Include the stacktrace of the data fetching exception in the log output smallrye.graphql.allowGet false Allow HTTP GET Method smallrye.graphql.metrics.enabled false Enable metrics smallrye.graphql.tracing.enabled false Enable tracing smallrye.graphql.validation.enabled true if Bean Validation is present Enable Bean Validation. This property is DEPRECATED, setting to false won't actually turn off validation. It will be removed in a future release. smallrye.graphql.events.enabled true if one of metrics, tracing or bean validation is true Enable eventing smallrye.graphql.logPayload false Log the payload in the log file smallrye.graphql.fieldVisibility To control the field visibility on introspection smallrye.graphql.schema.includeScalars true Include Scalar definitions in the schema smallrye.graphql.schema.includeSchemaDefinition false Include Schema definition smallrye.graphql.schema.includeDirectives false Include directives in the schema smallrye.graphql.schema.includeIntrospectionTypes false Include Introspection types in the schema","title":"From SmallRye GraphQL"},{"location":"typesafe-client-custom-scalars/","text":"Custom scalar types If the remote service contains custom scalar types represented as strings in GraphQL documents, a typesafe client can learn to understand these types through introducing a class that represents them. The class has to contain logic necessary for serializing and deserializing from/to raw strings. A model class is considered to represent a scalar GraphQL type if it contains a static builder method named of , valueOf , or parse whose sole parameter is a java.lang.String and it returns an instance of the class itself. The name of the GraphQL type is assumed to be equal to the short name of the class. For example, if the server supports a URL type (there is a scalar URL clause in the schema), create a class that represents a value for URL : public class URL { private String value ; public URL ( String value ) { this . value = value ; } public static URL valueOf ( String value ) { // <1> return new URL ( value ); } @Override public String toString () { // <2> return value ; } } <1> The static valueOf(String) method will be used for deserializing a URL from a string. <2> The toString() will be used for serializing a URL into a string to be sent to the GraphQL service","title":"Custom scalar types"},{"location":"typesafe-client-custom-scalars/#custom-scalar-types","text":"If the remote service contains custom scalar types represented as strings in GraphQL documents, a typesafe client can learn to understand these types through introducing a class that represents them. The class has to contain logic necessary for serializing and deserializing from/to raw strings. A model class is considered to represent a scalar GraphQL type if it contains a static builder method named of , valueOf , or parse whose sole parameter is a java.lang.String and it returns an instance of the class itself. The name of the GraphQL type is assumed to be equal to the short name of the class. For example, if the server supports a URL type (there is a scalar URL clause in the schema), create a class that represents a value for URL : public class URL { private String value ; public URL ( String value ) { this . value = value ; } public static URL valueOf ( String value ) { // <1> return new URL ( value ); } @Override public String toString () { // <2> return value ; } } <1> The static valueOf(String) method will be used for deserializing a URL from a string. <2> The toString() will be used for serializing a URL into a string to be sent to the GraphQL service","title":"Custom scalar types"},{"location":"typesafe-client-error-handling/","text":"Error handling in typesafe clients System-level errors If the service returns a system-level error (which means the response body doesn't contain a valid GraphQL response document), the client invocation will throw a io.smallrye.graphql.client.InvalidResponseException whose message contains information about the received status code, status message, and body contents. Application-level errors If the service returns one or more application-level errors (which means that there is valid GraphQL response in the body that has a non-empty errors entry), the client normally throws a GraphQLClientException containing the details in a list of GraphQLClientError . [NOTE] An error response is considered application-level regardless of the HTTP status code as long as it contains a valid GraphQL response. We define a GraphQL response as a well-formed JSON document that contains at least one of errors , data and extensions entries, and no other entries beyond that. If the error is specific to a location , you can use an ErrorOr wrapper on the target field; the client the maps the error to that wrapper instead of throwing an exception. I.e. your SuperHero class could look like this: class SuperHero { String name ; ErrorOr < Location > location ; } If the service returns a response like this: { \"data\" : { \"superHero\" : { \"name\" : \"Wolverine\" , \"location\" : null } }, \"errors\" : [{ \"message\" : \"location unknown\" , \"path\" : [ \"superHero\" , \"location\" ], \"extensions\" :{ \"code\" : \"location-unknown\" } }] } Then the SuperHero#location wrapper field will not contain a value but only the error above. See the ErrorOr class for details.","title":"Error handling"},{"location":"typesafe-client-error-handling/#error-handling-in-typesafe-clients","text":"","title":"Error handling in typesafe clients"},{"location":"typesafe-client-error-handling/#system-level-errors","text":"If the service returns a system-level error (which means the response body doesn't contain a valid GraphQL response document), the client invocation will throw a io.smallrye.graphql.client.InvalidResponseException whose message contains information about the received status code, status message, and body contents.","title":"System-level errors"},{"location":"typesafe-client-error-handling/#application-level-errors","text":"If the service returns one or more application-level errors (which means that there is valid GraphQL response in the body that has a non-empty errors entry), the client normally throws a GraphQLClientException containing the details in a list of GraphQLClientError . [NOTE] An error response is considered application-level regardless of the HTTP status code as long as it contains a valid GraphQL response. We define a GraphQL response as a well-formed JSON document that contains at least one of errors , data and extensions entries, and no other entries beyond that. If the error is specific to a location , you can use an ErrorOr wrapper on the target field; the client the maps the error to that wrapper instead of throwing an exception. I.e. your SuperHero class could look like this: class SuperHero { String name ; ErrorOr < Location > location ; } If the service returns a response like this: { \"data\" : { \"superHero\" : { \"name\" : \"Wolverine\" , \"location\" : null } }, \"errors\" : [{ \"message\" : \"location unknown\" , \"path\" : [ \"superHero\" , \"location\" ], \"extensions\" :{ \"code\" : \"location-unknown\" } }] } Then the SuperHero#location wrapper field will not contain a value but only the error above. See the ErrorOr class for details.","title":"Application-level errors"},{"location":"typesafe-client-headers/","text":"Adding headers To add a custom header to the http requests sent out by the GraphQL Client, annotate your method or the API interface as @Header , e.g.: @GraphQLClientApi interface SuperHeroesApi { @Header ( name = \"S.H.I.E.L.D.-Clearance\" , constant = \"TOP-SECRET\" ) List < SuperHero > allHeroesIn ( String location ); } The value can be specified with a constant or the name of a method for dynamic values, e.g.: @GraphQLClientApi interface SuperHeroesApi { @Header ( name = \"S.H.I.E.L.D.-Clearance\" , method = \"establishShieldClearance\" ) List < SuperHero > allHeroesIn ( String location ); static Clearance establishShieldClearance () { return userIsInRole ( MANAGER ) ? TOP_SECRET : PUBLIC ; } } This example uses an enum, but it can be any Object; the GraphQL client calls toString() to convert it. The method must be static and accessible by the interface, i.e. in the interface itself or in one of the classes it\u2019s nested in; if it\u2019s in a different class, prefix it with the fully qualified class name and a dot \".\" , e.g. @Header(name = \"S.H.I.E.L.D.-Clearance\", method = \"org.superheroes.SecurityTools.establishShieldClearance\") . A third option is to pass the value of a header as an API method parameter: @GraphQLClientApi interface SuperHeroesApi { List < SuperHero > allHeroesIn ( String location , @Header ( name = \"S.H.I.E.L.D.-Clearance\" ) Clearance clearance ); } The @Header parameter will not be part of the GraphQL query. The name of the header is always static, but can optionally be derived from the name of the parameter or method, i.e. if it has a @Name annotation, that annotation value is used. If it's not annotated, the method name (eventually stripped off a leading get ) or the parameter name (if it's enabled in the compiler settings) is converted from camel case to kebab case, i.e. a parameter @Header String requestIdentifier will result in a header named Request-Identifier . @Header annotations can also be defined via @Stereotype . When instantiating the API with the builder, you can set (or overwrite) one or more headers there: SuperHeroesApi api = TypesafeGraphQLClientBuilder . newBuilder () . header ( \"S.H.I.E.L.D.-Clearance\" , \"TOP-SECRET\" ) . build ( SuperHeroesApi . class ); Authorization headers To add an Authorization header, instead of using the generic @Header annotation, you can also use the special @AuthorizationHeader annotation. It produces a BASIC Authorization header by default or a BEARER token. You can configure the credentials in MP Config with a prefix plus /mp-graphql/ and either username and password for BASIC or bearer for BEARER . The config key defaults to the fully qualified name of the GraphQLClientApi interface or its configKey . You can use a custom prefix by setting the confPrefix . The infix /mp-graphql/ is still applied, unless you end the confPrefix with * , e.g. @AuthorizationHeader(confPrefix = \"org.superheroes.security.basic.* will use org.superheroes.security.basic.username , while * will use plain username . @AuthorizationHeader annotations can be defined via @Stereotype .","title":"Adding headers"},{"location":"typesafe-client-headers/#adding-headers","text":"To add a custom header to the http requests sent out by the GraphQL Client, annotate your method or the API interface as @Header , e.g.: @GraphQLClientApi interface SuperHeroesApi { @Header ( name = \"S.H.I.E.L.D.-Clearance\" , constant = \"TOP-SECRET\" ) List < SuperHero > allHeroesIn ( String location ); } The value can be specified with a constant or the name of a method for dynamic values, e.g.: @GraphQLClientApi interface SuperHeroesApi { @Header ( name = \"S.H.I.E.L.D.-Clearance\" , method = \"establishShieldClearance\" ) List < SuperHero > allHeroesIn ( String location ); static Clearance establishShieldClearance () { return userIsInRole ( MANAGER ) ? TOP_SECRET : PUBLIC ; } } This example uses an enum, but it can be any Object; the GraphQL client calls toString() to convert it. The method must be static and accessible by the interface, i.e. in the interface itself or in one of the classes it\u2019s nested in; if it\u2019s in a different class, prefix it with the fully qualified class name and a dot \".\" , e.g. @Header(name = \"S.H.I.E.L.D.-Clearance\", method = \"org.superheroes.SecurityTools.establishShieldClearance\") . A third option is to pass the value of a header as an API method parameter: @GraphQLClientApi interface SuperHeroesApi { List < SuperHero > allHeroesIn ( String location , @Header ( name = \"S.H.I.E.L.D.-Clearance\" ) Clearance clearance ); } The @Header parameter will not be part of the GraphQL query. The name of the header is always static, but can optionally be derived from the name of the parameter or method, i.e. if it has a @Name annotation, that annotation value is used. If it's not annotated, the method name (eventually stripped off a leading get ) or the parameter name (if it's enabled in the compiler settings) is converted from camel case to kebab case, i.e. a parameter @Header String requestIdentifier will result in a header named Request-Identifier . @Header annotations can also be defined via @Stereotype . When instantiating the API with the builder, you can set (or overwrite) one or more headers there: SuperHeroesApi api = TypesafeGraphQLClientBuilder . newBuilder () . header ( \"S.H.I.E.L.D.-Clearance\" , \"TOP-SECRET\" ) . build ( SuperHeroesApi . class );","title":"Adding headers"},{"location":"typesafe-client-headers/#authorization-headers","text":"To add an Authorization header, instead of using the generic @Header annotation, you can also use the special @AuthorizationHeader annotation. It produces a BASIC Authorization header by default or a BEARER token. You can configure the credentials in MP Config with a prefix plus /mp-graphql/ and either username and password for BASIC or bearer for BEARER . The config key defaults to the fully qualified name of the GraphQLClientApi interface or its configKey . You can use a custom prefix by setting the confPrefix . The infix /mp-graphql/ is still applied, unless you end the confPrefix with * , e.g. @AuthorizationHeader(confPrefix = \"org.superheroes.security.basic.* will use org.superheroes.security.basic.username , while * will use plain username . @AuthorizationHeader annotations can be defined via @Stereotype .","title":"Authorization headers"},{"location":"typesafe-client-logging/","text":"Logging in typesafe clients The Client implementation logs all GraphQL requests and responses at level INFO with the interface API as the logger name. It also logs the keys of all headers added at level DEBUG ; not the values, as they may be security sensitive.","title":"Logging"},{"location":"typesafe-client-logging/#logging-in-typesafe-clients","text":"The Client implementation logs all GraphQL requests and responses at level INFO with the interface API as the logger name. It also logs the keys of all headers added at level DEBUG ; not the values, as they may be security sensitive.","title":"Logging in typesafe clients"},{"location":"typesafe-client-multiple-queries/","text":"Multiple Say you need the result from several root queries, e.g. all superHeroes and all superVillains . Java only supports a single return value, so you\u2019ll need a wrapper class: @GraphQLClientApi interface SuperHeroesApi { HeroesAndVillains heroesAndVillains (); } @Multiple class HeroesAndVillains { List < SuperHero > superHeroes ; List < SuperVillain > superVillains ; } The @Multiple annotation 'inlines' the wrapper class, i.e. the actual query is: query heroesAndVillains { superHeroes {...} superVillains {...}} The actual response below will be mapped to an instance of the HeroesAndVillains wrapper class: { \"data\" : { \"superHeroes\" : [ ... ], \"superVillains\" : [ ... ] } } If the nested queries require parameters, use @ annotations to put them on the field (remember: GraphQL fields can have parameters). If you need the same request several times (e.g. with different query parameters), use @Name annotations, so the actual field names are used as alias .","title":"Running multiple queries at once"},{"location":"typesafe-client-multiple-queries/#multiple","text":"Say you need the result from several root queries, e.g. all superHeroes and all superVillains . Java only supports a single return value, so you\u2019ll need a wrapper class: @GraphQLClientApi interface SuperHeroesApi { HeroesAndVillains heroesAndVillains (); } @Multiple class HeroesAndVillains { List < SuperHero > superHeroes ; List < SuperVillain > superVillains ; } The @Multiple annotation 'inlines' the wrapper class, i.e. the actual query is: query heroesAndVillains { superHeroes {...} superVillains {...}} The actual response below will be mapped to an instance of the HeroesAndVillains wrapper class: { \"data\" : { \"superHeroes\" : [ ... ], \"superVillains\" : [ ... ] } } If the nested queries require parameters, use @ annotations to put them on the field (remember: GraphQL fields can have parameters). If you need the same request several times (e.g. with different query parameters), use @Name annotations, so the actual field names are used as alias .","title":"Multiple"},{"location":"typesafe-client-reactive-types/","text":"Reactive types usage in typesafe clients Reactive types with queries and mutations Regardless of the type that a query or mutation returns, you can always wrap the return type in a Uni in your @GraphQLClientApi interface. The Uni will be completed after the response is received and processed. Subscriptions The return type of a subscription operation must always be wrapped in a Multi . The communication with the server runs over a WebSocket. Important note about errors When using the typesafe client for subscriptions, if it is expected that the server might return errors, then it is highly recommended to wrap the return types into an ErrorOr (for example, turn the API method @Subscription Multi<Person> people into @Subscription Multi<ErrorOr<Person>> people ). The reason is once there is an error returned from the service and the result can't be turned into a domain object due to that, the Multi will receive a failure as a result. Because of the design of Mutiny, a Multi can't continue producing any items after a failure. That means the subscription will be cancelled after the first error, even though the server might continue sending more items. In such case, your application would have to detect the error and start a new subscription. See Error handling for more details on how to use ErrorOr . Subscription example Given a server-side definition like this: @Subscription public Multi < Integer > countToFive () { return Multi . createFrom (). range ( 0 , 5 ); } A client to consume this subscription can look like this: client . countToFive . subscribe () . with ( // onItem: i -> System . out . println ( \"Received number\" + i ), // onFailure: ( t ) -> t . printStackTrace () );","title":"Reactive"},{"location":"typesafe-client-reactive-types/#reactive-types-usage-in-typesafe-clients","text":"","title":"Reactive types usage in typesafe clients"},{"location":"typesafe-client-reactive-types/#reactive-types-with-queries-and-mutations","text":"Regardless of the type that a query or mutation returns, you can always wrap the return type in a Uni in your @GraphQLClientApi interface. The Uni will be completed after the response is received and processed.","title":"Reactive types with queries and mutations"},{"location":"typesafe-client-reactive-types/#subscriptions","text":"The return type of a subscription operation must always be wrapped in a Multi . The communication with the server runs over a WebSocket.","title":"Subscriptions"},{"location":"typesafe-client-reactive-types/#important-note-about-errors","text":"When using the typesafe client for subscriptions, if it is expected that the server might return errors, then it is highly recommended to wrap the return types into an ErrorOr (for example, turn the API method @Subscription Multi<Person> people into @Subscription Multi<ErrorOr<Person>> people ). The reason is once there is an error returned from the service and the result can't be turned into a domain object due to that, the Multi will receive a failure as a result. Because of the design of Mutiny, a Multi can't continue producing any items after a failure. That means the subscription will be cancelled after the first error, even though the server might continue sending more items. In such case, your application would have to detect the error and start a new subscription. See Error handling for more details on how to use ErrorOr .","title":"Important note about errors"},{"location":"typesafe-client-reactive-types/#subscription-example","text":"Given a server-side definition like this: @Subscription public Multi < Integer > countToFive () { return Multi . createFrom (). range ( 0 , 5 ); } A client to consume this subscription can look like this: client . countToFive . subscribe () . with ( // onItem: i -> System . out . println ( \"Received number\" + i ), // onFailure: ( t ) -> t . printStackTrace () );","title":"Subscription example"},{"location":"typesafe-client-usage/","text":"A Java code-first type-safe GraphQL Client API suggestion for Microprofile GraphQL Issue #185 . Basic Usage Creating the client-side counterpart of the GraphQL API: package examples.typesafeclient ; import io.smallrye.graphql.client.typesafe.api.GraphQLClientApi ; import java.util.List ; @GraphQLClientApi public interface SuperHeroesApi { List < SuperHero > allHeroesIn ( String location ); } A model class: package examples.typesafeclient ; import java.util.List ; public class SuperHero { private String name ; private List < String > superPowers ; // plus getters and setters } Injecting the client using CDI and using it: package examples.typesafeclient ; import jakarta.inject.Inject ; import java.util.List ; public class MyClientUsage { @Inject SuperHeroesApi superHeroesApi ; public void execute () { List < SuperHero > allHeroes = superHeroesApi . allHeroesIn ( \"Outer Space\" ); // ... } } The default request type is query . To make it a mutation, annotate it @Mutation . The parameter name is only available if you compile the source with the -parameters option. Otherwise, you\u2019ll have to annotate all parameters with @Name . The example above uses CDI, e.g. when you are in a MicroProfile or Jakarta EE environment. If you are in an environment without CDI support, you need to instantiate the API interface by using the builder: SuperHeroesApi api = TypesafeGraphQLClientBuilder . newBuilder (). build ( SuperHeroesApi . class ); The basic idea of the Java code-first approach is that you start by writing the DTOs and query/mutation methods as you need them in your client. This ensures that you don\u2019t request fields that you don\u2019t need; the thinking is inspired by Consumer Driven Contracts . If the server uses names different from yours, you can simply use annotations to do a mapping: Name Mapping / Aliases If the server defines a different field or parameter name, annotate it with @Name . If the server defines a different query name, annotate the method as, e.g., @Query(\"findHeroesCurrentlyLocatedIn\") . By renaming methods, you can also define several variations of the same request but using different return types or parameters. E.g.: public interface SuperHeroesApi { SuperHero findHeroByName ( String name ); @Query ( \"findHeroByName\" ) SuperHeroWithTeams findHeroWithTeamsByName ( String name ); } The SuperHero class has no team affiliations (for this example). The SuperHeroWithTeams class has a List<Team> teamAffiliations field. The actual query name is still findHeroByName . The Team class doesn\u2019t contain the members to break recursion. If you rename a field or method, the real field or method name will be used as an alias, so you can select the same data twice (see and below). Configuration If the endpoint is always the same, e.g. a public API of a cloud service, you can add the URL to your API annotation, e.g.: @GraphQLClientApi ( endpoint = \"https://superheroes.org/graphql\" ) interface SuperHeroesApi { } When instantiating the API with the builder, you can set (or overwrite) the endpoint there: SuperHeroesApi api = TypesafeGraphQLClientBuilder . newBuilder () . endpoint ( \"https://superheroes.org/graphql\" ) . build ( SuperHeroesApi . class ); Commonly you\u2019ll need different endpoints, e.g. when you need one endpoint for your production system, but a different endpoint for your test system. Simply use MicroProfile Config to set the endpoint; similar to the MicroProfile Rest Client , the key for the endpoint is the fully qualified name of the api interface, plus /mp-graphql/url , e.g.: org.superheroes.SuperHeroesApi/mp-graphql/url = https://superheroes.org/graphql If you want to use a different key, set the base config key on the annotation @GraphQLClientApi(configKey = \"superheroes\") ; then use this key for the endpoint superheroes/mp-graphql/url . When using the builder, you can override the config key as well: TypesafeGraphQLClientBuilder.newBuilder().configKey(\"superheroes\") . NestedParameter Some APIs require parameters beyond the root level, e.g. for filtering or paginating nested lists. Say you have a schema like this: type Query { team(name: String!): Team! } type Team { members(first: Int!): [SuperHero!]! } To pass the parameter to the nested field/method, annotate it as @NestedParameter , e.g.: @GraphQLClientApi interface TeamsApi { Team team ( String name , @NestedParameter ( \"members\" ) int first ); } The value of the @NestedParameter annotation is the dot-delimited path to the nested field/method that the value should be added to.","title":"Basic usage"},{"location":"typesafe-client-usage/#basic-usage","text":"Creating the client-side counterpart of the GraphQL API: package examples.typesafeclient ; import io.smallrye.graphql.client.typesafe.api.GraphQLClientApi ; import java.util.List ; @GraphQLClientApi public interface SuperHeroesApi { List < SuperHero > allHeroesIn ( String location ); } A model class: package examples.typesafeclient ; import java.util.List ; public class SuperHero { private String name ; private List < String > superPowers ; // plus getters and setters } Injecting the client using CDI and using it: package examples.typesafeclient ; import jakarta.inject.Inject ; import java.util.List ; public class MyClientUsage { @Inject SuperHeroesApi superHeroesApi ; public void execute () { List < SuperHero > allHeroes = superHeroesApi . allHeroesIn ( \"Outer Space\" ); // ... } } The default request type is query . To make it a mutation, annotate it @Mutation . The parameter name is only available if you compile the source with the -parameters option. Otherwise, you\u2019ll have to annotate all parameters with @Name . The example above uses CDI, e.g. when you are in a MicroProfile or Jakarta EE environment. If you are in an environment without CDI support, you need to instantiate the API interface by using the builder: SuperHeroesApi api = TypesafeGraphQLClientBuilder . newBuilder (). build ( SuperHeroesApi . class ); The basic idea of the Java code-first approach is that you start by writing the DTOs and query/mutation methods as you need them in your client. This ensures that you don\u2019t request fields that you don\u2019t need; the thinking is inspired by Consumer Driven Contracts . If the server uses names different from yours, you can simply use annotations to do a mapping:","title":"Basic Usage"},{"location":"typesafe-client-usage/#name-mapping-aliases","text":"If the server defines a different field or parameter name, annotate it with @Name . If the server defines a different query name, annotate the method as, e.g., @Query(\"findHeroesCurrentlyLocatedIn\") . By renaming methods, you can also define several variations of the same request but using different return types or parameters. E.g.: public interface SuperHeroesApi { SuperHero findHeroByName ( String name ); @Query ( \"findHeroByName\" ) SuperHeroWithTeams findHeroWithTeamsByName ( String name ); } The SuperHero class has no team affiliations (for this example). The SuperHeroWithTeams class has a List<Team> teamAffiliations field. The actual query name is still findHeroByName . The Team class doesn\u2019t contain the members to break recursion. If you rename a field or method, the real field or method name will be used as an alias, so you can select the same data twice (see and below).","title":"Name Mapping / Aliases"},{"location":"typesafe-client-usage/#configuration","text":"If the endpoint is always the same, e.g. a public API of a cloud service, you can add the URL to your API annotation, e.g.: @GraphQLClientApi ( endpoint = \"https://superheroes.org/graphql\" ) interface SuperHeroesApi { } When instantiating the API with the builder, you can set (or overwrite) the endpoint there: SuperHeroesApi api = TypesafeGraphQLClientBuilder . newBuilder () . endpoint ( \"https://superheroes.org/graphql\" ) . build ( SuperHeroesApi . class ); Commonly you\u2019ll need different endpoints, e.g. when you need one endpoint for your production system, but a different endpoint for your test system. Simply use MicroProfile Config to set the endpoint; similar to the MicroProfile Rest Client , the key for the endpoint is the fully qualified name of the api interface, plus /mp-graphql/url , e.g.: org.superheroes.SuperHeroesApi/mp-graphql/url = https://superheroes.org/graphql If you want to use a different key, set the base config key on the annotation @GraphQLClientApi(configKey = \"superheroes\") ; then use this key for the endpoint superheroes/mp-graphql/url . When using the builder, you can override the config key as well: TypesafeGraphQLClientBuilder.newBuilder().configKey(\"superheroes\") .","title":"Configuration"},{"location":"typesafe-client-usage/#nestedparameter","text":"Some APIs require parameters beyond the root level, e.g. for filtering or paginating nested lists. Say you have a schema like this: type Query { team(name: String!): Team! } type Team { members(first: Int!): [SuperHero!]! } To pass the parameter to the nested field/method, annotate it as @NestedParameter , e.g.: @GraphQLClientApi interface TeamsApi { Team team ( String name , @NestedParameter ( \"members\" ) int first ); } The value of the @NestedParameter annotation is the dot-delimited path to the nested field/method that the value should be added to.","title":"NestedParameter"},{"location":"using-smallrye-stork/","text":"Using SmallRye Stork SmallRye GraphQL client (both dynamic and typesafe) supports SmallRye Stork for service discovery and load balancing. If your client is configured to connect to a URI with the stork:// or storks:// scheme, then Stork will be used to determine the actual endpoints to connect to. Load balancing, if configured, will be applied in a way that each HTTP request can be routed to a different service instance. For WebSocket traffic, once a WebSocket connection is established, the client will keep using that connection for as long as possible. If that connection is lost for any reason and needs to be reestablished, then the load balancer can route it to a different instance. Using with Quarkus The dependency on Stork is declared as optional, so if you want to use it, you might need to add it explicitly. If you're using Quarkus, use the Stork extension along with the desired service discovery implementation, for example: <dependency> <groupId>io.quarkus</groupId> <artifactId>quarkus-smallrye-stork</artifactId> </dependency> <dependency> <groupId>io.smallrye.stork</groupId> <artifactId>smallrye-stork-service-discovery-static-list</artifactId> </dependency> Example configuration in Quarkus application.properties : quarkus.smallrye-graphql-client.myclient.url=stork://foo-service/graphql quarkus.stork.foo-service.service-discovery.type=static quarkus.stork.foo-service.service-discovery.address-list=server1.com:8080,server2.com:8080 When running as a standalone application If you're using the client in a standalone mode outside any container that handles Stork initialization for you, you might need two additional steps to get it working: Add a configuration provider for Stork, such as <dependency> <groupId>io.smallrye.stork</groupId> <artifactId>stork-microprofile-config</artifactId> </dependency> And before initializing any GraphQL client instances, make sure that Stork is initialized by calling io.smallrye.stork.Stork.initialize() once.","title":"Using SmallRye Stork"},{"location":"using-smallrye-stork/#using-smallrye-stork","text":"SmallRye GraphQL client (both dynamic and typesafe) supports SmallRye Stork for service discovery and load balancing. If your client is configured to connect to a URI with the stork:// or storks:// scheme, then Stork will be used to determine the actual endpoints to connect to. Load balancing, if configured, will be applied in a way that each HTTP request can be routed to a different service instance. For WebSocket traffic, once a WebSocket connection is established, the client will keep using that connection for as long as possible. If that connection is lost for any reason and needs to be reestablished, then the load balancer can route it to a different instance.","title":"Using SmallRye Stork"},{"location":"using-smallrye-stork/#using-with-quarkus","text":"The dependency on Stork is declared as optional, so if you want to use it, you might need to add it explicitly. If you're using Quarkus, use the Stork extension along with the desired service discovery implementation, for example: <dependency> <groupId>io.quarkus</groupId> <artifactId>quarkus-smallrye-stork</artifactId> </dependency> <dependency> <groupId>io.smallrye.stork</groupId> <artifactId>smallrye-stork-service-discovery-static-list</artifactId> </dependency> Example configuration in Quarkus application.properties : quarkus.smallrye-graphql-client.myclient.url=stork://foo-service/graphql quarkus.stork.foo-service.service-discovery.type=static quarkus.stork.foo-service.service-discovery.address-list=server1.com:8080,server2.com:8080","title":"Using with Quarkus"},{"location":"using-smallrye-stork/#when-running-as-a-standalone-application","text":"If you're using the client in a standalone mode outside any container that handles Stork initialization for you, you might need two additional steps to get it working: Add a configuration provider for Stork, such as <dependency> <groupId>io.smallrye.stork</groupId> <artifactId>stork-microprofile-config</artifactId> </dependency> And before initializing any GraphQL client instances, make sure that Stork is initialized by calling io.smallrye.stork.Stork.initialize() once.","title":"When running as a standalone application"}]}