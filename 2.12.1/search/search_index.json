{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>SmallRye GraphQL is a library that allows you to easily use GraphQL (both server-side endpoints and client-side code) in your Java-based projects. It implements the MicroProfile GraphQL specification. </p>"},{"location":"client-standalone/","title":"Bootstraping GraphQL clients","text":"<p>In general, it is recommended to use SmallRye GraphQL client through the Quarkus extension, or the WildFly feature pack, each of them having their own documentation about how to set up dependencies and bootstrap a client. It is however also possible to use SmallRye GraphQL Client in a standalone application outside any container. The single dependency that you need is <code>io.smallrye:smallrye-graphql-client-implementation-vertx</code>, as the Vert.x based implementation is currently the only supported one.</p> <p>If you're using the client as a script and notice that the JVM doesn't exit even after you close the client instance, it's probably because the client is maintaining a <code>Vertx</code> instance that it created automatically. To solve this issue, you might need to create a <code>Vertx</code> instance on your own, pass it to the client builder, and then close it after closing the client. See the following JBang snippet for an example.</p>"},{"location":"client-standalone/#logging-with-a-standalone-java-se-application-using-the-smallrye-graphql-client","title":"Logging with a standalone (Java SE) application using the SmallRye GraphQL Client","text":"<p>If you want to properly configure logging in a standalone application, you will also need to add a logging implementation to the classpath. The client code uses the JBoss Logging facade, so you can, for example, use the JBoss Logmanager. Add the <code>org.jboss.logmanager:jboss-logmanager</code> dependency to your project(it needs to be on the runtime classpath). You will also need to run the application with this system property declared: <code>-Djava.util.logging.manager=org.jboss.logmanager.LogManager</code>.</p> <p>To customize logging levels etc, it picks up the <code>logging.properties</code> file from the root of the runtime classpath, so, for example if using Maven and the exec plugin to start the application, you would place the file into <code>src/main/resources/logging.properties</code>. For an example of the contents of this file, see https://github.com/jamezp/jboss-logging-example/blob/master/src/main/resources/logging.properties.</p>"},{"location":"client-standalone/#using-with-jbang","title":"Using with JBang","text":"<p>This is a full script runnable directly with JBang that uses a dynamic client for connecting to countries.trevorblades.com to obtain a list of countries from its database.</p> <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n//DEPS io.smallrye:smallrye-graphql-client-implementation-vertx:RELEASE\n\nimport io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient;\nimport io.smallrye.graphql.client.Response;\nimport io.smallrye.graphql.client.vertx.dynamic.VertxDynamicGraphQLClientBuilder;\n\nimport io.vertx.core.Vertx;\n\n// Has a multiline string literal, requires Java 15+!\nclass Client {\n    public static void main(String... args) throws Exception {\n        Vertx vertx = Vertx.vertx();\n        DynamicGraphQLClient client = new VertxDynamicGraphQLClientBuilder()\n            .url(\"https://countries.trevorblades.com\")\n            .vertx(vertx)\n            .build();\n        try {\n            Response response = client.executeSync(\"\"\"\n                query {\n                  countries {\n                    name\n                  }\n                }\n                \"\"\");\n            System.out.println(response);\n        } finally {\n            client.close();\n            vertx.close();\n        }\n    }\n}\n</code></pre> <p>Save this file as <code>Client.java</code> and execute with <code>jbang Client.java</code>.</p>"},{"location":"client_configuration/","title":"Client-side configuration properties","text":"<p>Note: if you are using Quarkus, it is recommended to use the <code>quarkus.*</code> property counterparts instead.  See Quarkus Documentation for more info. </p> Property Default value Meaning <code>CLIENT_NAME/mp-graphql/url</code> none Denotes URL to connect to <code>CLIENT_NAME/mp-graphql/header/KEY</code> none Adds a HTTP header named <code>KEY</code> to all HTTP requests performed by the client <code>CLIENT_NAME/mp-graphql/subprotocols</code> <code>graphql-ws,graphql-transport-ws</code> Comma-separated list of websocket subprotocols supported by this client. We currently support <code>graphql-ws</code> and <code>graphql-transport-ws</code>. If multiple subprotocols are provided, choosing the actual subprotocol will be subject to negotiation with the server. <code>CLIENT_NAME/mp-graphql/keystore</code> none Path to client's keystore (for example <code>file:/path/to/keystore</code> or <code>classpath:path/to/keystore</code>) <code>CLIENT_NAME/mp-graphql/keystoreType</code> <code>JKS</code> Keystore type <code>CLIENT_NAME/mp-graphql/keystorePassword</code> none Keystore password <code>CLIENT_NAME/mp-graphql/truststore</code> none Path to client's truststore (for example <code>file:/path/to/truststore</code> or <code>classpath:path/to/truststore</code>) <code>CLIENT_NAME/mp-graphql/truststoreType</code> <code>JKS</code> Truststore type <code>CLIENT_NAME/mp-graphql/truststorePassword</code> none Truststore password <code>CLIENT_NAME/mp-graphql/proxyHost</code> none Hostname of the proxy to use <code>CLIENT_NAME/mp-graphql/proxyPort</code> none Port of the proxy to use <code>CLIENT_NAME/mp-graphql/proxyUsername</code> none Username for the proxy to use <code>CLIENT_NAME/mp-graphql/proxyPassword</code> none Password for the proxy to use <code>CLIENT_NAME/mp-graphql/maxRedirects</code> 16 Max number of redirects to follow. Set to 0 to disable redirects. <code>CLIENT_NAME/mp-graphql/websocketInitializationTimeout</code> none Maximum time in milliseconds that will be allowed to wait for the server to acknowledge a websocket connection. <code>CLIENT_NAME/mp-graphql/runSingleOperationsOverWebsocket</code> <code>false</code> If true, then queries and mutations will run over the websocket transport rather than pure HTTP. Off by default, because it has higher overhead. <code>CLIENT_NAME/mp-graphql/initPayload/KEY</code> none Adds a property named <code>KEY</code> to the <code>connection_init</code> message payload when negotiating a websocket connection. All values will be treated as string. For other types instatiate the API with the builder. <code>CLIENT_NAME/mp-graphql/allowUnexpectedResponseFields</code> <code>false</code> If true and there is an unexpected field in the response payload, it won't throw an error, and it will log a warning message."},{"location":"custom-error-extensions/","title":"GraphQL Error Extensions","text":"<p>Exceptions are reported in GraphQL in the <code>errors</code> array, next to the <code>data</code> field, so it's possible to return partial results, e.g.:</p> <pre><code>{\n  \"data\": {\n    \"superHero\": {\n      \"name\": \"Wolverine\",\n      \"location\": null\n    }\n  },\n  \"errors\": [{\n    \"message\":\"location unknown\",\n    \"path\": [\"superHero\",\"location\"],\n    \"extensions\":{\"code\":\"location-unknown\"}\n  }]\n}\n</code></pre> <p>The <code>location</code> field couldn't be returned, and in the <code>errors</code>, there's the reason with a few predefined fields, and a map of <code>extensions</code> that can contain custom details about the error.</p> <p>You can add your own extensions by implementing the <code>io.smallrye.graphql.api.ErrorExtensionProvider</code> interface and adding your class name to a file <code>META-INF/services/io.smallrye.graphql.api.ErrorExtensionProvider</code> (this is a <code>ServiceLoader</code>).</p> <p>As an example, this class provides an extension named <code>exception-length</code> with the length of the simple class name of the exception:</p> <pre><code>public class ExceptionLengthErrorExtensionProvider implements ErrorExtensionProvider {\n    @Override\n    public String getKey() {\n        return \"exception-length\";\n    }\n\n    @Override\n    public JsonNumber mapValueFrom(Throwable exception) {\n        return Json.createValue(exception.getClass().getSimpleName().length());\n    }\n}\n</code></pre>"},{"location":"custom-json-serializers-deserializers/","title":"Customizing JSON-B serializers/deserializers","text":"<p>If your application needs finer-grained control over JSON serialization/deserialization than you can achieve via formatting annotations like <code>@JsonbDateFormat</code>, you may plug in your own custom instances of the <code>Jsonb</code> class for each input type that your GraphQL application exposes.</p> <p>To do this, you'll need to create an implementation of <code>io.smallrye.graphql.spi.EventingService</code> and implement its <code>overrideJsonbConfig</code> method.  An example that plugs in a custom date format for a particular class that is used as input:</p> <pre><code>package org.acme.custom.json.config;\n\npublic class CustomJsonbService implements EventingService {\n\n    @Override\n    public String getConfigKey() {\n        return null; // activate this service always regardless of the configuration \n    }\n\n    @Override\n    public Map&lt;String, Jsonb&gt; overrideJsonbConfig() {\n        JsonbConfig config = new JsonbConfig().withDateFormat(\"MM dd yyyy HH:mm Z\", null).withDeserializers(OBJECTID_DESERIALIZER).withSerializers(\n            OBJECTID_SERIALIZER);\n        return Collections.singletonMap(\"MyModelClass.class.getName()\", JsonbBuilder.create(config));\n    }\n}\n</code></pre> <p>We can customize the JsonbConfig as per our need in above example we have registered additional serializer and date formatting for the class MyModelClass.</p> <p>As the discovery of eventing services uses the ServiceLoader mechanism, don't forget to add a  <code>META-INF/services/io.smallrye.graphql.spi.EventingService</code> file that contains the fully qualified  name of your implementation. Example <code>org.acme.custom.json.config.CustomJsonbService</code></p>"},{"location":"custom-scalar/","title":"Creating GraphQL Custom Scalars with SmallRye GraphQL","text":"<p>While by default MicroProfile GraphQL specification doesn't provide direct support for creating custom scalars for GraphQL literal types of String, Int and Float, SmallRye GraphQL has implemented  this feature based on user feedback. To implement a custom scalar with SmallRye GraphQL,  you can annotate your custom scalar class with <code>@CustomScalar</code> in addition to following the pattern below  of including a public constructor that takes one of <code>String</code>|<code>BigDecimal</code>|<code>BigInteger</code> depending on  the scalar type: <pre><code>  @CustomScalar(\"BigDecimalString\")\n  public class BigDecimalString implements CustomStringScalar {\n    public BigDecimalString(String stringValue) {\n        ...\n    }\n    @Override\n    public String stringValueForSerialization() {\n        ...\n  }\n}\n</code></pre> In this example, <code>BigDecimalString</code> implements the <code>CustomStringScalar</code> which is used to identify the  proper (de) serialization for BigDecimalString.  <code>BigDecimalString</code> also provides a single argument constructor which takes a String.  Finally, <code>BigDecimalString</code> implements  <code>stringValueForSerialization()</code> which provides the String representation to be used during  serialization.</p> <p>[NOTE] If the user wants to create a literal for GraphQL Int or Float, they would implement either  CustomIntScalar with the intValueForSerialization method or CustomFloatScalar with the floatValueForSerialization method respectively.</p>"},{"location":"directives/","title":"Directives","text":""},{"location":"directives/#custom-directives","title":"Custom Directives","text":"<p>You can add your own GraphQL Directives by writing a corresponding Java Annotation and annotate it as <code>@Directive</code>, e.g.:</p> <pre><code>@Directive(on = { OBJECT, INTERFACE })\n@Description(\"Just a test\")\n@Retention(RUNTIME)\npublic @interface MyDirective {\n}\n</code></pre> <p>Directives can be repeatable, see the <code>@Key</code> annotation for an example.</p>"},{"location":"directives/#directives-generated-from-bean-validation-annotations","title":"Directives generated from Bean Validation annotations","text":"<p>If your project uses Bean Validation to validate fields on input types and operation arguments, and you enable  inclusion of directives in the schema (by setting <code>smallrye.graphql.schema.includeDirectives=true</code>),  then constraints decoded from annotations will be added to your schema as directives. This is currently only  supported for some built-in constraints (annotations from the  <code>javax.validation.constraints</code> package), and custom constraints aren't supported at all. </p> <p>Each bean validation annotation is mapped to a single <code>@constraint</code> directive. The directive is declared as repeatable, so if you have multiple constraints on an input field, the field will contain multiple <code>@constraint</code> directives. The following table describes the mapping between BV annotations and <code>@constraint</code> directives (all currently supported  BV annotations are listed here): </p> BV annotation GraphQL directive <code>@Size(MIN, MAX)</code> <code>@constraint(minLength=MIN, maxLength=MAX)</code> <code>@Email</code> <code>@constraint(format='email')</code> <code>@Max</code> <code>@constraint(max=VALUE)</code> <code>@Min</code> <code>@constraint(min=VALUE)</code> <code>@Pattern(REGEXP)</code> <code>@constraint(pattern=REGEXP)</code> <p>Note: The <code>@NotNull</code> annotation does not map to a directive, instead it makes the GraphQL type non-nullable.</p> <p>Constraints will only appear on fields of input types and operation arguments.</p>"},{"location":"dynamic-client-error-handling/","title":"Error handling with dynamic clients","text":""},{"location":"dynamic-client-error-handling/#system-level-errors","title":"System-level errors","text":"<p>If the service returns a system-level error (which means the response body doesn't contain a valid GraphQL response document), the client invocation will (instead of returning a  <code>io.smallrye.graphql.client.Response</code>) throw a <code>io.smallrye.graphql.client.InvalidResponseException</code> whose message contains information about the received status code, status message, and body contents.</p>"},{"location":"dynamic-client-error-handling/#application-level-errors","title":"Application-level errors","text":"<p>If the service returns one or more application-level errors (which means that there is valid GraphQL response in the body that has a non-empty <code>errors</code> entry), the client invocation will return a <code>io.smallrye.graphql.client.Response</code> as normal, and that object will contain information about the errors. Errors are represented as <code>io.smallrye.graphql.client.GraphQLError</code> objects and can be inspected after retrieving a list of all errors using <code>response.getErrors()</code>.</p> <p>[NOTE] An error response is considered application-level regardless of the HTTP status code as long as it contains a valid GraphQL response. We define a GraphQL response as a well-formed JSON document that contains at least one of <code>errors</code>, <code>data</code> and <code>extensions</code> entries, and no other entries beyond that.</p> <p>It is also possible to convert a response's errors into a <code>io.smallrye.graphql.client.GraphQLClientException</code> by calling <code>throwExceptionIfErrors()</code> - the response has to be cast to <code>ResponseImpl</code> for this as of now. This method will, if there are any errors in the response, convert the errors into a <code>GraphQLClientException</code>  and throw it.</p> <p>If you need to access the HTTP response code and message pertaining to a response that contained application-level errors, refer to Accessing HTTP headers and response codes.</p>"},{"location":"dynamic-client-usage/","title":"Dynamic client introduction and basic usage","text":"<p>A Java GraphQL client. The main difference from the typesafe client is that while the typesafe client behaves like a typesafe proxy very similar to the MicroProfile REST Client, the dynamic client is more like the JAX-RS client from the <code>jakarta.ws.rs.client</code> package. Instead of working with model classes directly, the dynamic client focuses on programmatically working with GraphQL documents representing GraphQL requests and responses. It still offers the option to convert between documents and model classes when necessary.</p> <p>In the current implementation, Vert.x HTTP client is used for handling the underlying traffic.</p>"},{"location":"dynamic-client-usage/#creating-a-client-instance","title":"Creating a client instance","text":"<p>Generally there are two ways to obtain a client instance.</p> <p>First, using CDI injection where the configuration values are defined in system properties:</p> <pre><code>@Inject\n@GraphQLClient(\"superheroes\")\nDynamicGraphQLClient client;\n\n// assuming that this system property exists:\n// superheroes/mp-graphql/url=https://superheroes.org/graphql\n</code></pre> <p>The above example assumes that configuration for the client is present in system properties. For a full list of supported configuration properties, see Client configuration reference</p> <p>The other way to build a client is programmatically using a builder:</p> <pre><code>DynamicGraphQLClient client = DynamicGraphQLClientBuilder.newBuilder()\n    .url(\"https://superheroes.org/graphql\")\n    .build();\n</code></pre> <p>The usage examples in the following sections will assume using the first approach - injection.</p>"},{"location":"dynamic-client-usage/#basic-usage","title":"Basic Usage","text":"<p>Given the following GraphQL service on the server side:</p> <pre><code>@GraphQLApi\nclass SuperHeroesApi {\n    @Query\n    List&lt;SuperHero&gt; allHeroesIn(String location) {\n        // ....\n    }\n}\n\nclass SuperHero {\n    private String name;\n    private List&lt;String&gt; superPowers;\n}\n</code></pre> <p>Such service can be queried this way:</p> <pre><code>package examples.dynamicclient;\n\nimport examples.typesafeclient.SuperHero;\nimport io.smallrye.graphql.client.GraphQLClient;\nimport io.smallrye.graphql.client.Response;\nimport io.smallrye.graphql.client.core.Document;\nimport io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient;\n\nimport jakarta.inject.Inject;\nimport jakarta.json.JsonArray;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\n\nimport static io.smallrye.graphql.client.core.Argument.arg;\nimport static io.smallrye.graphql.client.core.Argument.args;\nimport static io.smallrye.graphql.client.core.Document.document;\nimport static io.smallrye.graphql.client.core.Field.field;\nimport static io.smallrye.graphql.client.core.Operation.operation;\n\npublic class MyClientUsage {\n\n    @Inject\n    @GraphQLClient(\"superHeroes\")\n    DynamicGraphQLClient client;\n\n    public void execute() throws ExecutionException, InterruptedException {\n        Document document = document(   // &lt;1&gt;\n            operation(field(\"allHeroesIn\",\n                args(arg(\"location\", \"Outer Space\")),\n                field(\"name\"),\n                field(\"superPowers\"))));\n        Response response = client.executeSync(document); // &lt;2&gt;\n\n        JsonArray heroesArray = response.getData().getJsonArray(\"allHeroesIn\");  // &lt;3&gt;\n        List&lt;SuperHero&gt; heroes = response.getList(SuperHero.class, \"allHeroesIn\"); // &lt;4&gt;\n    }\n}\n</code></pre> <ul> <li> <p>&lt;1&gt; Creating the document representing the request. We used static     imports to make the code easy to read, they all come from the     classes in the <code>io.smallrye.graphql.client.core</code> package.</p> </li> <li> <p>&lt;2&gt; Executing the request. You can either do that in a blocking way, or     request a <code>Uni</code> if you prefer the reactive style.</p> </li> <li> <p>&lt;3&gt; Obtaining the resulting list of heroes as a <code>JsonArray</code>.</p> </li> <li> <p>&lt;4&gt; Obtaining the resulting list of heroes as instances of the model     class. This is optional, you can continue working with the data as a <code>JsonArray</code> if you prefer.</p> </li> </ul>"},{"location":"dynamic-client-usage/#using-plain-strings-instead-of-the-dsl","title":"Using plain strings instead of the DSL","text":"<p>If you don't like the DSL for some reason and want to use plain strings for your queries, these two examples will serve you:</p> <pre><code>package examples.dynamicclient;\n\nimport io.smallrye.graphql.client.GraphQLClient;\nimport io.smallrye.graphql.client.Response;\nimport io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient;\n\nimport jakarta.inject.Inject;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\n\npublic class MyClientUsageString {\n\n    @Inject\n    @GraphQLClient(\"superheroes\")\n    DynamicGraphQLClient client;\n\n    public void execute() throws ExecutionException, InterruptedException {\n        String queryWithInlineVariables =   // &lt;1&gt;\n            \"query {\" +\n            \"  allHeroesIn(location: \\\"Outer Space\\\") {\" +\n            \"    name\" +\n            \"    superPowers\" +\n            \"  }\" +\n            \"}\";\n        Response response = client.executeSync(queryWithInlineVariables);\n\n        String queryWithExtractedVariables =   // &lt;2&gt;\n            \"query($loc: String) {\" +\n            \"  allHeroesIn(location: $loc) {\" +\n            \"    name\" +\n            \"    superPowers\" +\n            \"  }\" +\n            \"}\";\n        Map&lt;String, Object&gt; variables = new HashMap&lt;&gt;(); // &lt;3&gt;\n        variables.put(\"loc\", \"Outer Space\");\n        Response response2 = client.executeSync(queryWithExtractedVariables, variables);\n    }\n}\n</code></pre> <ul> <li> <p>&lt;1&gt;: In this variant, we inline values for query arguments directly into the query string.</p> </li> <li> <p>&lt;2&gt;: In this variant, argument values are extracted into variables. The <code>location</code> argument of the <code>allHeroesIn</code> query is      declared to be using the variable <code>loc</code> (the variable can also be named <code>location</code> same as the argument, if     you prefer).</p> </li> <li> <p>&lt;3&gt;: Here we create a map that defines the values for each variable. Values of this map are <code>Object</code>s,     so you can put in strings, numbers, booleans, or any object that corresponds to a GraphQL type and can be     serialized to JSON. Inserting a <code>JsonObject</code> directly is also supported.</p> </li> </ul>"},{"location":"dynamic-client-usage/#accessing-http-headers-and-response-codes","title":"Accessing HTTP headers and response codes","text":"<p>To access HTTP transport metadata that was passed by the server, you can inspect the <code>Response</code> object.</p> <p><code>Response.getTransportMeta(\"HEADER-NAME\")</code> returns a <code>List&lt;String&gt;</code> containing (potentially multiple) values of the requested header.</p> <p>To get the HTTP status code or status message, these are stored inside the <code>transportMeta</code> map too. <code>ResponseImpl</code>  contains convenience methods to retrieve them: <code>ResponseImpl.getStatusCode()</code> and <code>ResponseImpl.getStatusMessage()</code>. It's also possible to retrieve them directly without casting to <code>ResponseImpl</code> by calling <code>Integer.valueOf(response.getTransportMeta().get(\"&lt;status-code&gt;\").get(0))</code> and <code>response.getTransportMeta().get(\"&lt;status-message&gt;\").get(0)</code>.</p> <p>HTTP headers, status codes and messages are only available for operations executed over pure HTTP, not via websockets!</p>"},{"location":"extensions/","title":"Adding extensions to GraphQL response","text":"<p>SmallRye GraphQL allows the user to add their own extensions inside the GraphQL response which is received from the server. The <code>extensions</code> are stored next to the <code>data</code> field in the GraphQL response.</p> <pre><code>{\n  \"data\": {\n    \"shirt\": {\n      \"size\": \"L\"\n    }\n  },\n  \"extensions\": {\n    \"country\": \"Germany\",\n    \"pi\": 3.1415926535\n  }\n}\n</code></pre> <p>To add extensions, you need to <code>@Inject</code> an instance of <code>SmallRyeContext</code> in your <code>@GraphQLApi</code> annotated class. After that, you can add your own extensions via the method <code>addExtensions</code> with its input parameters: <code>key : String</code> as an identification of the added extension. And <code>value: Object</code> as a value of the extension. Value can be any given object that can be converted into JsonValue.</p> <p>As an example, this class below contains the query <code>getShirt</code> and during the http request, the query adds these extensions: <code>{\"country\": \"Germany\", \"pi\": 3.1415926535}</code>. These extensions will be sent back via response in the <code>extensions</code> field. <pre><code>import jakarta.inject.Inject;\n\n@GraphQLApi\npublic class ShirtResources {\n    @Inject\n    SmallRyeContext smallRyeContext;\n\n    @Query\n    public Shirt getShirt() {\n        smallRyeContext.addExtensions(\"country\", \"Germany\");\n        smallRyeContext.addExtensions(\"pi\", 3.1415926535);\n        //...\n    }\n}\n</code></pre></p> <p>[NOTE] You can also use the method <code>setAddedExtensions(Map&lt;String, Object&gt; addedExtensions)</code> to set all the extensions with map instance.</p>"},{"location":"federation/","title":"Federation","text":"<p>Support for GraphQL Federation is enabled by default. If you add one of the federation annotations, the corresponding directives will be declared in your schema, and the additional Federation queries will be added automatically. You can also disable Federation completely by setting the <code>smallrye.graphql.federation.enabled</code> config key to <code>false</code>.</p> <p>You can add the Federation directives by using the equivalent Java annotation, e.g. to extend a <code>Product</code> entity with a <code>price</code> field, you can write a class:</p> <pre><code>package org.example.price;\n\nimport org.eclipse.microprofile.graphql.Id;\n\nimport io.smallrye.graphql.api.federation.Extends;\nimport io.smallrye.graphql.api.federation.Key;\n\n@Extends @Key(fields = @FieldSet(\"id\"))\npublic class Product {\n    @Id\n    private String id;\n\n    @Description(\"The price in cent\")\n    private Integer price;\n\n    // getters and setters omitted\n}\n</code></pre> <p>And a normal query method that takes the <code>key</code> fields as a parameter and returns the requested type:</p> <pre><code>package org.example.price;\n\nimport org.eclipse.microprofile.graphql.GraphQLApi;\nimport org.eclipse.microprofile.graphql.Id;\nimport org.eclipse.microprofile.graphql.Query;\n\n@GraphQLApi\npublic class Prices {\n    @Query\n    public Product product(@Id String id) {\n        return [...]\n    }\n}\n</code></pre> <p>The GraphQL Schema then contains:</p> <pre><code>type Product @extends @key(fields : \"id\") {\n    id: ID\n    price: Int\n}\n\nunion _Entity = Product\n\ntype Query {\n    _entities(representations: [_Any!]!): [_Entity]!\n    _service: _Service!\n    product(id: ID): Product\n}\n</code></pre> <p>If you can resolve, e.g., the product with different types of ids, you can add multiple <code>@Key</code> annotations.</p>"},{"location":"federation/#federation-batch-resolver","title":"Federation Batch Resolver","text":"<p>For better performance, there is the option to use batch resolvers with federation. This is not activated by default. It can be activated by setting <code>smallrye.graphql.federation.batchResolving.enabled</code> config key to <code>true</code>.</p> <p>It is unnecessary to provide batch resolvers for all entities, if there is no batch resolver, a non-batch resolver is used.</p> <pre><code>package org.example.price;\n\nimport org.eclipse.microprofile.graphql.GraphQLApi;\nimport org.eclipse.microprofile.graphql.Id;\nimport org.eclipse.microprofile.graphql.Query;\n\n@GraphQLApi\npublic class Prices {\n    @Query\n    public List&lt;Product&gt; product(@Id List&lt;String&gt; id) {\n        return [...]\n    }\n}\n</code></pre> <p>It is crucial that the sequence of the argument list matches the order of the result list. Currently, the name of the Argument <code>id</code> must match with the property name in the type.</p>"},{"location":"federation/#federation-reference-resolver","title":"Federation Reference Resolver","text":"<p>In federation, you may also want to extend the external type by some fields without publishing queries into the schema. You can do it by using the annotation <code>@Resolver</code>.</p> <pre><code>@Extends\n@Key(fields = @FieldSet(\"upc\"))\npublic final class Product {\n    @External\n    @NonNull\n    private String upc;\n    @External\n    private Integer weight;\n    @External\n    private Integer price;\n    private Boolean inStock;\n    @Requires(fields = @FieldSet(\"price weight\"))\n    private Integer shippingPrice;\n}\n\n@GraphQLApi\npublic class Api {\n    @Query // 0 query, that will be added into schema\n    public Product findByUPC(String upc) {\n        return new Product(upc , ...etc);\n    }\n\n    @Resolver // 1 You dont receive external fields price weight here, just key\n    public Product resolveByUPC(String upc) {\n        return new Product(upc , ...etc);\n    }\n\n    @Resolver // 2 The order of variables doesn't matter\n    public Product resolveByUPCForShipping(int price, String upc, @Name(\"weight\") int someWeight) {\n        return new Product(upc , someWeight, price, (price * someWeight) /*calculate shippingPrice */, ...etc);\n    }\n\n    @Resolver // 3 \n    public Product resolveByUPCForSource(int price, String upc) {\n        return new Product(upc, price, ...etc);\n    }\n\n    @Requires(fields = @FieldSet(\"price\"))\n    public int anotherWeight(@Source Product product) {\n        return product.price() * 2;\n    }\n}\n</code></pre> <p>Generates the following schema: <pre><code>type Product @extends @key(fields : \"upc\") {\n  anotherWeight: Int! @requires(fields : \"price\")\n  inStock: Boolean\n  price: Int @external\n  shippingPrice: Int @requires(fields : \"price weight\")\n  upc: String! @external\n  weight: Int @external\n}\n\ntype Query {\n  _entities(representations: [_Any!]!): [_Entity]!\n  _service: _Service!\n}\n</code></pre></p> <p>These methods will only be available to the federation router, which may send requests like the following examples: <pre><code>// request 1\nquery {\n  _entities(representations: [{ \n    \"__typename\": \"Product\", \n    \"upc\": \"1\" // just id key\n  }]) {\n    __typename\n    ... on Product {\n      inStock\n    }\n  }\n}\n\n// request 2\nquery {  \n  _entities(representations: [{ \n    \"__typename\": \"Product\", \n    \"upc\": \"1\", // id key\n    \"price\": 100, // shippingPrice requires this field\n    \"weight\": 100  // shippingPrice requires this field\n  }]) {\n    __typename\n    ... on Product {\n      inStock\n      shippingPrice\n    }\n  }\n}\n\n// request 3\nquery {\n  _entities(representations: [{\n    \"__typename\": \"Product\",\n    \"upc\": \"2\",\n    \"price\": 1299  // anotherWeight requires this field\n  }\n  ]) {\n    __typename\n    ... on Product {\n      anotherWeight\n    }\n  }\n}\n</code></pre></p> <p>Unfortunately, you must make separate methods with different <code>@External</code> parameters.</p> <p>It is not currently possible to combine them into one separate type.</p> <p>You also can use <code>@Query</code> (if you want to add queries into the schema) or <code>@Resolver</code> (requests 0 and 1). And if it was requested, <code>_entities</code> - <code>@Resolvers</code> methods are checked first (they have higher priority). </p>"},{"location":"gradle-plugin/","title":"SmallRye GraphQL Gradle plugin","text":"<p>This Gradle plugin allows you to generate the GraphQL Schema on build and save it as a text file.</p> <p>Add this to your build.gradle:</p> <pre><code>plugins {\n    id 'io.smallrye.graphql' version 'PLUGIN_VERSION'\n}\n</code></pre> <p>The list of existing plugin versions (to substitute the <code>PLUGIN_VERSION</code> placeholder) can be found here.</p> <p>The schema will appear as <code>build/generated/schema.graphql</code> by default.</p> <p>The plugin\u2019s <code>generateSchema</code> task can customized like:</p> <pre><code>generateSchema {\n    destination = null\n    includeTransitiveDependencies = true\n    includeScalars = true\n}\n</code></pre> <p>This will include the project\u2019s dependencies (including the transitive dependencies) to scan for GraphQL model classes. As the destination is set to <code>null</code> the generated schema will only be output to the console and saved to a file.</p> <p>In case external dependencies need to be scanned for GraphQL model classes a more advanced configuration could look like:</p> <pre><code>configrations {\n    graphQLSchema\n}\n\ndependencies {\n    graphQLSchema ..\n}\n\ngenerateSchema {\n    includeDependencies = true\n    configurations = [\"graphQLSchema\"]\n}\n</code></pre> <p>This defines a separate <code>graphQLSchema</code> configuration. In the dependencies block the external dependencies containing the GraphQL mode class should then be registered for the <code>graphQLSchema</code> configuration. The <code>generateSchema</code> task is then customized to only include dependencies from the <code>graphQLSchema</code> configuration. Also note that we set <code>includeDependencies</code> to <code>true</code> (and not <code>includeTransitiveDependencies</code>). This will make sure only direct dependencies will be be scanned and not possible transitive dependencies.</p>"},{"location":"gradle-plugin/#configuration-options","title":"Configuration options","text":"<ul> <li> <p><code>destination</code> - To override the default     <code>build/generated/schema.graphql</code> destination.</p> </li> <li> <p><code>includeDependencies</code> - Scan project\u2019s dependencies for GraphQL     model classes too. Default false.</p> </li> <li> <p><code>includeTransitiveDependencies</code> - Scan project\u2019s dependencies     (including the transitive dependencies) for GraphQL model classes     too. Default false.</p> </li> <li> <p><code>configurations</code> - If the above <code>includeDependencies</code> or     <code>includeTransitiveDependencies</code> is true, you can control what     configurations should be included. Default is <code>implementation</code>.</p> </li> <li> <p><code>dependencyExtensions</code> - If the above <code>includeDependencies</code> or     <code>includeTransitiveDependencies</code> is true, you can control what     dependency extensions should be included. Default is <code>jar</code>.</p> </li> <li> <p><code>includeScalars</code> - Include scalars in the schema. Default false.</p> </li> <li> <p><code>includeDirectives</code> - Include directives in the schema. Default     false.</p> </li> <li> <p><code>includeSchemaDefinition</code> - Include the schema definition. Default     false.</p> </li> <li> <p><code>includeIntrospectionTypes</code> - Include the introspection types in the     schema. Default false.</p> </li> </ul>"},{"location":"handling-init-payload-from-the-websocket/","title":"Handling of the WebSocket's init-payload","text":"<p>When executing GraphQL operations over WebSockets (both with the <code>graphql-ws</code> and <code>graphql-transport-ws</code> protocols), the client can send an initial payload to the server when establishing the WebSocket connection. This payload can contain any information that the server might need to process GraphQL requests, like client agent identification (similar to the <code>User-Agent</code> header) or data specific to the client. On the server-side, you can access this payload via the <code>GraphQLContext</code>, which is available through the <code>DataFetchingEnvironment</code> object. <pre><code>@GraphQLApi\npublic class HeroResources {\n\n    @Inject\n    SmallryeContext context;\n\n    // ... \n        Map&lt;String, Object&gt; initPayload = smallRyeContext\n            .getDataFetchingEnvironment()\n            .getGraphQlContext()\n            .get(\"init-payload\");\n    // ...\n}\n</code></pre></p>"},{"location":"inspecting-executable-directives-on-server-side/","title":"Inspecting executable directives on the server side","text":"<p>Let's say you have this GraphQL query with an executable directive on a field location. <pre><code>{\n    hero(name: $nameValue) {\n        name\n        location @customDirective(arg: true)\n    }\n}\n</code></pre></p> <p>To inspect your directive on the server side, you must inject a <code>SmallRyeContext</code> object and get the relevant information like this. <pre><code>    @Inject\n    SmallRyeContext context;\n\n    @Query\n    public SuperHero getHero(String name) {\n        // ...\n        SelectionSet selectionSet = (SelectionSet) context.getDataFetchingEnvironment().getField().getChildren().get(0);\n        Optional&lt;Node&gt; locationNode = selectionSet.getChildren().stream()\n            .filter(node -&gt; node instanceof Field &amp;&amp; ((Field) node).getName().equals(\"location\")).findAny(); // \"location\" is the field name where the directive is applied.\n        locationNode.ifPresent(node -&gt; {\n            List&lt;Directive&gt; directives = ((Field) node).getDirectives();\n            System.out.println(directives);\n            });\n        // the rest of the query...\n    }\n</code></pre></p> <p>[NOTE]  that <code>Field</code> refers to <code>graphql.language.Field</code>, not <code>io.smallrye.graphql.schema.model.Field</code></p>"},{"location":"maven-plugin/","title":"SmallRye GraphQL Maven plugin","text":"<p>This Maven plugin allows you to generate the GraphQL Schema on build and save it as a text file.</p> <p>Add this to your pom.xml:</p> <pre><code>&lt;plugin&gt;\n    &lt;artifactId&gt;smallrye-graphql-maven-plugin&lt;/artifactId&gt;\n    &lt;groupId&gt;io.smallrye&lt;/groupId&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;generate-schema&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre> <p>The schema will appear as <code>target/generated/schema.graphql</code> by default. The goal is bound to the <code>process-classes</code>  build phase.</p>"},{"location":"maven-plugin/#configuration-options","title":"Configuration options","text":"<ul> <li> <p><code>destination</code> - To override the default <code>target/generated/schema.graphql</code> destination</p> </li> <li> <p><code>includeDependencies</code> - Scan project\u2019s dependencies for GraphQL model classes too. This is necessary if your GraphQL endpoint exposes classes that are not in the application's main module. Off (<code>false</code>) by default, because scanning a potentially large dependency tree slows down execution substantially. Usage of reactive types does not require turning this option on. </p> </li> <li> <p><code>includeDependenciesScopes</code> - If the above <code>includeDependencies</code> is true, you can control what scopes should be included. Default is <code>compile, system</code></p> </li> <li> <p><code>includeDependenciesTypes</code> - If the above <code>includeDependencies</code> is true, you can control what types should be included. Default is <code>jar</code></p> </li> <li> <p><code>includeScalars</code> - Include scalars in the schema. Default false.</p> </li> <li> <p><code>includeDirectives</code> - Include directives in the schema. Default false.</p> </li> <li> <p><code>includeSchemaDefinition</code> - Include the schema definition. Default false.</p> </li> <li> <p><code>includeIntrospectionTypes</code> - Include the introspection types in the schema. Default false.</p> </li> <li> <p><code>federationEnabled</code> - Enable GraphQL Federation. This is automatically  enabled if any Federation-related annotations are found in your application, otherwise the default is false. You should generally use this in conjunction with <code>includeDirectives</code>.</p> </li> <li> <p><code>typeAutoNameStrategy</code> - Strategy for transforming class names into GraphQL type names.  Valid values are <code>MergeInnerClass</code>, <code>Full</code> and<code>Default</code>.</p> </li> </ul>"},{"location":"mutation-void/","title":"Returning Void Type in Mutations with SmallRye GraphQL","text":"<p>While by default MicroProfile GraphQL specification doesn't provide direct support for returning <code>void</code> type from mutation operations, SmallRye GraphQL has implemented this feature based on user feedback.</p> <p>To implement a mutation operation that returns <code>void</code> or <code>Void</code> type, you can use the following pattern in your annotated <code>@GraphQLApi</code> class: <pre><code>    @Mutation\n    public void createHero(SuperHero hero) {\n        superHeroService.create(hero);\n    }\n</code></pre> In this example, <code>createHero()</code> receives a SuperHero object as input, performs some operation with it (in this case, creating it using a <code>superHeroService</code>).</p> <p>[NOTE] On the GraphQL level, this is achieved by returning a special scalar type named Void from the mutation. This scalar type will always have a value of null.</p>"},{"location":"namespaces-on-server-side/","title":"Namespacing on the server side","text":"<p>[NOTE] Using approaches to form namespaces in the schema can be useful for large APIs. There are several ways to do this. However, read the documentation carefully, especially the limitations and possible problems.</p> <p>[NOTE] You can only use one of the annotations - <code>@Name</code> or <code>@Namespace</code> over the GraphQLApi classes.</p>"},{"location":"namespaces-on-server-side/#using-namespace-annotation","title":"Using @Namespace annotation","text":"<p>The annotation accepts an array of strings containing the nesting of the namespace.  This method allows you to create any nesting of namespaces. You can use any nesting and also combine different levels.</p> <pre><code>@GraphQLApi\n@Namespace({\"admin\", \"users\"})\n@Description(\"Admin users operations\")\npublic class AdminUsersApi {\n    @Query\n    public List&lt;User&gt; findAll() {\n        //\n    }\n}\n\n@GraphQLApi\n@Namespace({\"admin\"})\n@Description(\"Admin operations\")\npublic class AdminApi {\n    @Query\n    public List&lt;Admin&gt; findAll() {\n        //\n    }\n}\n</code></pre> <p>Will generate schema <pre><code>\"Query root\"\ntype Query {\n  admin: AdminQuery\n}\n\n\"Admin operations\"\ntype AdminQuery {\n  users: AdminUsersQuery\n  findAll: [Admin]\n}\n\n\"Admin users operations\"\ntype AdminUsersQuery {\n  findAll: [User]\n}\n\ntype Admin {\n  id: BigInteger\n  ...\n}\n\ntype User {\n  id: BigInteger\n  ...\n}\n</code></pre></p> <p>And you can send GraphQL request like: <pre><code>query {\n  admin {\n    users {\n      findAll {\n        id\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"namespaces-on-server-side/#using-name-annotation-deprecated","title":"Using @Name annotation (deprecated)","text":"<p>[NOTE] This feature may be removed in the future.</p> <p>It does the same thing as <code>@Namespace</code>, the only difference is that there can only be one nesting level. <pre><code>@GraphQLApi\n@Name(\"users\")\n@Description(\"Users operations\")\npublic class UserApi {\n    @Query\n    public List&lt;User&gt; findAll() {\n        //\n    }\n}\n</code></pre> As a result, you can get methods with the same names. <pre><code>query {\n  users {\n    findAll {\n      ....\n    }\n  }\n}\n</code></pre></p>"},{"location":"namespaces-on-server-side/#problems","title":"Problems","text":"<p>While dividing APIs into namespaces may seem convenient, several issues are important to be aware of.</p>"},{"location":"namespaces-on-server-side/#mutations","title":"Mutations","text":"<p>On the client side, be careful when working with mutations. This violates the GraphQL specification since mutations in this form can be executed in parallel. Read more here about namespaces Namespacing by Separation of Concerns. This article describes how to work with namespaces, what problems you may encounter, and how to solve them.</p> <p>What does GraphQL say about this - \"GraphQL\" Nested Mutations</p> <p>In summary, you can use nested mutations, but with some overhead on the client side. Be careful with mutations.</p>"},{"location":"namespaces-on-server-side/#subscriptions","title":"Subscriptions","text":"<p>GraphQL does not guarantee subscription resolution within namespaces. While you can define subscriptions in namespaces, the generated schema will be valid, but the subscription will not be resolved. For example, if you try to run such a subscription request, you will get an error. This is the behavior of <code>graphql-java</code>. <pre><code>@GraphQLApi\n@Namepace(\"resource\")\npublic class ResourceApi {\n    @Subscription\n    public Multi&lt;ResourceSubscription&gt; resourceChange() {\n        //\n    }\n}\n</code></pre></p> <pre><code>subscription {\n  resource {\n    resourceChange {\n      ....\n    }\n  }\n}\n</code></pre> <p>There is currently no way around this problem. You must move subscriptions into a separate <code>@GraphQLApi</code> class that does not declare any namespace.</p> <p>[NOTE]  Be very careful when designing API with namespace. And be aware of all the potential consequences when working with mutations and subscriptions.</p>"},{"location":"server_configuration/","title":"Configuration properties","text":"<p>These are properties understood directly by SmallRye GraphQL. If you're using SmallRye GraphQL through Quarkus, these will generally work, but Quarkus offers its own counterparts for most of these,  and it is recommended to use the <code>quarkus.*</code> properties. Refer to the Quarkus documentation:  Server and Client side Quarkus properties.</p>"},{"location":"server_configuration/#from-microprofile-graphql","title":"From MicroProfile GraphQL","text":"Property Default value Meaning <code>mp.graphql.defaultErrorMessage</code> <code>Server Error</code> Error message for hidden exceptions <code>mp.graphql.hideErrorMessage</code> Runtime exceptions Exceptions that will be hidden <code>mp.graphql.showErrorMessage</code> Checked exceptions Exceptions that will not be hidden."},{"location":"server_configuration/#from-smallrye-graphql","title":"From SmallRye GraphQL","text":"Property Default value Meaning <code>smallrye.graphql.printDataFetcherException</code> <code>false</code> Include the stacktrace of the data fetching exception in the log output <code>smallrye.graphql.allowGet</code> <code>false</code> Allow HTTP GET Method <code>smallrye.graphql.metrics.enabled</code> <code>false</code> Enable metrics <code>smallrye.graphql.tracing.enabled</code> <code>false</code> Enable tracing <code>smallrye.graphql.validation.enabled</code> <code>true</code> if Bean Validation is present Enable Bean Validation. This property is DEPRECATED, setting to <code>false</code> won't actually turn off validation. It will be removed in a future release. <code>smallrye.graphql.events.enabled</code> <code>true</code> if one of metrics, tracing or bean validation is true Enable eventing <code>smallrye.graphql.logPayload</code> <code>false</code> Log the payload in the log file <code>smallrye.graphql.fieldVisibility</code> To control the field visibility on introspection <code>smallrye.graphql.schema.includeScalars</code> <code>true</code> Include Scalar definitions in the schema <code>smallrye.graphql.schema.includeSchemaDefinition</code> <code>false</code> Include Schema definition <code>smallrye.graphql.schema.includeDirectives</code> <code>false</code> Include directives in the schema <code>smallrye.graphql.schema.includeIntrospectionTypes</code> <code>false</code> Include Introspection types in the schema"},{"location":"typesafe-client-accessing-metadata-of-responses/","title":"Accessing Metadata of GraphQL Responses with TypesafeResponse","text":"<p>The TypesafeResponse class provides a wrapper around the \"data\" field of GraphQL responses, along with additional metadata such as errors, extensions, and transport metadata. Here are the methods you can use to access each type of metadata:</p>"},{"location":"typesafe-client-accessing-metadata-of-responses/#transport-metadata","title":"Transport metadata","text":"<p>use <code>getTransportMeta()</code> method to retrieve a map of transport metadata associated with the response.</p> <p>[NOTE] Note that the transport metadata referred to in the context of HTTP requests and responses is commonly found in the headers of the communication. Therefore, the getTransportMeta() method mentioned here can be used to retrieve a map of HTTP headers.</p>"},{"location":"typesafe-client-accessing-metadata-of-responses/#extensions","title":"Extensions","text":"<p>use <code>getExtensions()</code> method to retrieve a JsonObject of response extensions. The method returns a JSON object that represents the response extensions.</p>"},{"location":"typesafe-client-accessing-metadata-of-responses/#data","title":"Data","text":"<p>use <code>get()</code> method to retrieve the data object. The method returns the data object if it exists and there are no errors. If there are errors, it throws a NoSuchElementException with the error message.</p>"},{"location":"typesafe-client-accessing-metadata-of-responses/#errors","title":"Errors","text":"<p>use <code>getErrors()</code> method to retrieve a list of GraphQL errors. The method returns a list of errors if there are errors and no data object. If there is a data object, it throws a NoSuchElementException with the error message.</p> <p>[NOTE] Note that the get() method assumes that the response has a data object, and will throw an exception if there are errors without a data object. If you want to check for errors before retrieving the data object, use the hasErrors() method, which returns true if there are errors and false otherwise.</p> <p>You can use these methods to access and process the metadata of GraphQL responses returned by the TypesafeResponse class.</p> <p>Let's say you want to get as a client extensions from the GraphQL response. First of all you will need to modify your <code>GraphQLClientApi</code> interface to have your return type class (in this case <code>SuperHero</code>) wrapped with <code>TypesafeResponse</code> class. I.e. your <code>GraphQLClientApi</code> interface could look like this:</p> <pre><code>import examples.typesafeclient.SuperHero;\nimport io.smallrye.graphql.client.typesafe.api.TypesafeResponse;\n\n@GraphQLClientApi\npublic interface SuperHeroApi {\n    // ...\n    TypesafeResponse&lt;SuperHero&gt; findSuperHeroByName(String name);\n    // ...\n}\n</code></pre> <p>[NOTE] Note that you can have <code>TypesafeResponse&lt;T&gt;</code> only as a result (return) type of your query. Unlike <code>ErrorOr</code> the class cannot wrap individual fields. If that is the case <code>IllegalArgumentException</code> will be thrown.   </p> <p>And now to get <code>extensions</code> from the response your code will look like something like this: <pre><code>    @Inject\n    SuperHeroApi client;\n\n    TypesafeResponse&lt;SuperHero&gt; superheroResponse = client.findSuperHeroByName(\"Batman\");\n    // returns the \"data\" field\n    SuperHero superhero = superhero.get();\n    // returns the \"extensions\" field\n    JsonObject extensions = superhero.getExtensions();\n</code></pre></p>"},{"location":"typesafe-client-custom-scalars/","title":"Custom scalar types","text":"<p>If the remote service contains custom scalar types represented as strings in GraphQL documents, a typesafe client can learn to understand these types through introducing a class that represents them. The class has to contain logic necessary for serializing and deserializing from/to raw strings.</p> <p>A model class is considered to represent a scalar GraphQL type if it contains a static builder method named <code>of</code>, <code>valueOf</code>, or <code>parse</code> whose sole parameter is a <code>java.lang.String</code> and it returns an  instance of the class itself. The name of the GraphQL type is assumed to be equal to the short name of the class.</p> <p>For example, if the server supports a <code>URL</code> type (there is a <code>scalar URL</code> clause in the schema),  create a class that represents a value for <code>URL</code>:</p> <pre><code>public class URL {\n\n    private String value;\n\n    public URL(String value) {\n        this.value = value;\n    }\n\n    public static URL valueOf(String value) {  // &lt;1&gt;\n        return new URL(value);\n    }\n\n    @Override\n    public String toString() {   // &lt;2&gt;\n        return value;\n    }\n}\n</code></pre> <ul> <li>&lt;1&gt; The static <code>valueOf(String)</code> method will be used for deserializing a <code>URL</code> from a string.</li> <li>&lt;2&gt; The <code>toString()</code> will be used for serializing a <code>URL</code> into a string to be sent to the GraphQL service</li> </ul>"},{"location":"typesafe-client-directives/","title":"Typesafe Client Static Directives","text":""},{"location":"typesafe-client-directives/#custom-static-directives","title":"Custom Static Directives","text":"<p>The declaration of custom static directives for the typesafe client follows the same principles as the server-side directives. With only exception of using the Executable Directive Locations instead of Type System Directive Locations. <pre><code>@Directive(on = { FIELD, VARIABLE_DEFINITION })\n@Retention(RUNTIME)\npublic @interface MyDirective {\n    String value() default \"\";\n}\n</code></pre></p> <p>Applying this to your API should look like this: <pre><code>import io.smallrye.graphql.client.typesafe.api.GraphQLClientApi;\n\n@GraphQLClientApi\npublic @interface MyClientApi {\n\n    @Query\n    @MyDirective(\"top-level field\")\n    MySuperHero getMySuperHero(@MyDirective(\"variable definition\") String nameOfMySuperHero);\n\n    class MySuperHero {\n        @MyDirective(\"field\")\n        String name;\n    }\n}\n</code></pre> Your API is going to generate a query something like this: <pre><code>query mySuperHero(\n  $nameOfMySuperHero: String @myDirective(value: \"variable definition\")\n) {\n  mySuperHero(nameOfMySuperHero: $nameOfMySuperHero)\n    @myDirective(value: \"top-level field\") {\n    name @myDirective(value: \"field\")\n  }\n}\n</code></pre></p> <p>[NOTE] The current implementation supports only FIELD and VARIABLE_DEFINITION locations.</p>"},{"location":"typesafe-client-error-handling/","title":"Error handling in typesafe clients","text":""},{"location":"typesafe-client-error-handling/#system-level-errors","title":"System-level errors","text":"<p>If the service returns a system-level error (which means the response body doesn't contain a valid GraphQL response document), the client invocation will throw a <code>io.smallrye.graphql.client.InvalidResponseException</code> whose message contains information about the received status code, status message, and body contents.</p>"},{"location":"typesafe-client-error-handling/#application-level-errors","title":"Application-level errors","text":"<p>If the service returns one or more application-level errors (which means that there is valid GraphQL response in the body that has a non-empty <code>errors</code> entry),  the client normally throws a <code>GraphQLClientException</code> containing the details in a list of <code>GraphQLClientError</code>.</p> <p>[NOTE] An error response is considered application-level regardless of the HTTP status code as long as it contains a valid GraphQL response. We define a GraphQL response as a well-formed JSON document that contains at least one of <code>errors</code>, <code>data</code> and <code>extensions</code> entries, and no other entries beyond that.</p> <p>If the error is specific to a <code>location</code>, you can use an <code>ErrorOr</code> wrapper on the target field; the client the maps the error to that wrapper instead of throwing an exception. I.e. your <code>SuperHero</code> class could look like this:</p> <pre><code>class SuperHero {\n    String name;\n    ErrorOr&lt;Location&gt; location;\n}\n</code></pre> <p>If the service returns a response like this:</p> <pre><code>{\n  \"data\": {\n    \"superHero\": {\n      \"name\": \"Wolverine\",\n      \"location\": null\n    }\n  },\n  \"errors\": [{\n    \"message\":\"location unknown\",\n    \"path\": [\"superHero\",\"location\"],\n    \"extensions\":{\"code\":\"location-unknown\"}\n  }]\n}\n</code></pre> <p>Then the <code>SuperHero#location</code> wrapper field will not contain a <code>value</code> but only the error above. See the <code>ErrorOr</code> class for details.</p>"},{"location":"typesafe-client-headers/","title":"Adding headers","text":"<p>To add a custom header to the http requests sent out by the GraphQL Client, annotate your method or the API interface as <code>@Header</code>, e.g.:</p> <pre><code>@GraphQLClientApi\ninterface SuperHeroesApi {\n    @Header(name = \"S.H.I.E.L.D.-Clearance\", constant = \"TOP-SECRET\")\n    List&lt;SuperHero&gt; allHeroesIn(String location);\n}\n</code></pre> <p>The value can be specified with a <code>constant</code> or the name of a <code>method</code> for dynamic values, e.g.:</p> <pre><code>@GraphQLClientApi\ninterface SuperHeroesApi {\n    @Header(name = \"S.H.I.E.L.D.-Clearance\", method = \"establishShieldClearance\")\n    List&lt;SuperHero&gt; allHeroesIn(String location);\n\n    static Clearance establishShieldClearance() { \n        return userIsInRole(MANAGER) ? TOP_SECRET : PUBLIC;\n    }\n}\n</code></pre> <ul> <li>This example uses an enum, but it can be any Object; the GraphQL client     calls <code>toString()</code> to convert it.</li> </ul> <p>The method must be <code>static</code> and accessible by the interface, i.e. in the interface itself or in one of the classes it\u2019s nested in; if it\u2019s in a different class, prefix it with the fully qualified class name and a dot <code>\".\"</code>, e.g. <code>@Header(name = \"S.H.I.E.L.D.-Clearance\", method = \"org.superheroes.SecurityTools.establishShieldClearance\")</code>.</p> <p>A third option is to pass the value of a header as an API method parameter:</p> <pre><code>@GraphQLClientApi\ninterface SuperHeroesApi {\n    List&lt;SuperHero&gt; allHeroesIn(String location, @Header(name = \"S.H.I.E.L.D.-Clearance\") Clearance clearance);\n}\n</code></pre> <p>The <code>@Header</code> parameter will not be part of the GraphQL query.</p> <p>The <code>name</code> of the header is always static, but can optionally be derived from the name of the parameter or method, i.e. if it has a <code>@Name</code> annotation, that annotation value is used. If it's not annotated, the method name (eventually stripped off a leading <code>get</code>) or the parameter name (if it's enabled in the compiler settings) is converted from camel case to kebab case, i.e. a parameter <code>@Header String requestIdentifier</code> will result in a header named <code>Request-Identifier</code>.</p> <p><code>@Header</code> annotations can also be defined via <code>@Stereotype</code>.</p> <p>When instantiating the API with the builder, you can set (or overwrite) one or more headers there:</p> <pre><code>SuperHeroesApi api = TypesafeGraphQLClientBuilder.newBuilder()\n    .header(\"S.H.I.E.L.D.-Clearance\", \"TOP-SECRET\")\n    .build(SuperHeroesApi.class);\n</code></pre>"},{"location":"typesafe-client-headers/#authorization-headers","title":"Authorization headers","text":"<p>To add an <code>Authorization</code> header, instead of using the generic <code>@Header</code> annotation, you can also use the special <code>@AuthorizationHeader</code> annotation. It produces a <code>BASIC</code> <code>Authorization</code> header by default or a <code>BEARER</code> token. You can configure the credentials in MP Config with a prefix plus <code>/mp-graphql/</code> and either <code>username</code> and <code>password</code> for <code>BASIC</code> or <code>bearer</code> for <code>BEARER</code>. The config key defaults to the fully qualified name of the <code>GraphQLClientApi</code> interface or its <code>configKey</code>.</p> <p>You can use a custom prefix by setting the <code>confPrefix</code>. The infix <code>/mp-graphql/</code> is still applied, unless you end the <code>confPrefix</code> with <code>*</code>, e.g. <code>@AuthorizationHeader(confPrefix = \"org.superheroes.security.basic.*</code> will use <code>org.superheroes.security.basic.username</code>, while <code>*</code> will use plain <code>username</code>.</p> <p><code>@AuthorizationHeader</code> annotations can be defined via <code>@Stereotype</code>.</p>"},{"location":"typesafe-client-logging/","title":"Logging in typesafe clients","text":"<p>The Client implementation logs all GraphQL requests and responses at level <code>INFO</code> with the interface API as the logger name. It also logs the keys of all headers added at level <code>DEBUG</code>; not the values, as they may be security sensitive.</p>"},{"location":"typesafe-client-multiple-queries/","title":"Multiple","text":"<p>Say you need the result from several root queries, e.g. all <code>superHeroes</code> and all <code>superVillains</code>. Java only supports a single return value, so you\u2019ll need a wrapper class:</p> <pre><code>@GraphQLClientApi\ninterface SuperHeroesApi {\n    HeroesAndVillains heroesAndVillains();\n}\n\n@Multiple\nclass HeroesAndVillains {\n    List&lt;SuperHero&gt; superHeroes;\n    List&lt;SuperVillain&gt; superVillains;\n}\n</code></pre> <p>The <code>@Multiple</code> annotation 'inlines' the wrapper class, i.e. the actual query is:</p> <pre><code>query heroesAndVillains { superHeroes {...} superVillains {...}}\n</code></pre> <p>The actual response below will be mapped to an instance of the <code>HeroesAndVillains</code> wrapper class:</p> <pre><code>{\n  \"data\": {\n    \"superHeroes\": [ ... ],\n    \"superVillains\": [ ... ]\n  }\n}\n</code></pre> <p>If the nested queries require parameters, use <code>@</code> annotations to put them on the field (remember: GraphQL fields can have parameters).</p> <p>If you need the same request several times (e.g. with different query parameters), use <code>@Name</code> annotations, so the actual field names are used as alias.</p>"},{"location":"typesafe-client-reactive-types/","title":"Reactive types usage in typesafe clients","text":""},{"location":"typesafe-client-reactive-types/#reactive-types-with-queries-and-mutations","title":"Reactive types with queries and mutations","text":"<p>Regardless of the type that a query or mutation returns, you can always wrap the return type in a <code>Uni</code> in your <code>@GraphQLClientApi</code> interface. The <code>Uni</code> will be completed after the response is received and processed.</p>"},{"location":"typesafe-client-reactive-types/#subscriptions","title":"Subscriptions","text":"<p>The return type of a subscription operation must always be wrapped in a <code>Multi</code>. The communication with the server runs over a WebSocket.</p>"},{"location":"typesafe-client-reactive-types/#important-note-about-errors","title":"Important note about errors","text":"<p>When using the typesafe client for subscriptions, if it is expected that the server might return errors, then it is highly recommended to wrap the return types into an <code>ErrorOr</code> (for example, turn the API method <code>@Subscription Multi&lt;Person&gt; people</code> into <code>@Subscription Multi&lt;ErrorOr&lt;Person&gt;&gt; people</code>). The reason is once there is an error returned from the service and the result can't be turned into a domain object due to that, the <code>Multi</code> will receive a failure as a result. Because of the design of Mutiny, a <code>Multi</code> can't continue producing any items after a failure. That means the subscription will be cancelled after the first error, even though the server might continue sending more items. In such case, your application would have to detect the error and start a new subscription. See Error handling for more details on how to use <code>ErrorOr</code>.</p>"},{"location":"typesafe-client-reactive-types/#subscription-example","title":"Subscription example","text":"<p>Given a server-side definition like this:</p> <pre><code>@Subscription\npublic Multi&lt;Integer&gt; countToFive() {\n    return Multi.createFrom().range(0, 5);\n}\n</code></pre> <p>A client to consume this subscription can look like this: <pre><code>client.countToFive\n    .subscribe()\n    .with( // onItem:\n        i -&gt; System.out.println(\"Received number\" + i),\n        // onFailure:\n        (t) -&gt; t.printStackTrace()\n    );\n</code></pre></p>"},{"location":"typesafe-client-unions-and-interfaces/","title":"Unions &amp; Interfaces","text":"<p>If you consume a GraphQL service with a schema containing either a <code>Union</code> or an <code>Interface</code>, the client needs to request different fields via fragments, depending on the requested sub-type, and deserialize a polymorphic type.</p> <p>This is quite complex on the GraphQL side, but the typesafe client makes it very easy to use.</p>"},{"location":"typesafe-client-unions-and-interfaces/#unions","title":"Unions","text":"<p>One common use-case for Unions is returning a business error, e.g. when searching for a super hero, either you find a super hero and maybe you want the name and other fields, or you don't find it, and maybe you want a message with the reason. Such a query could look like this:</p> <pre><code>query find($name: String) {\n    find(name: $name){\n        __typename\n        ... on SuperHero {name}\n        ... on SuperHeroNotFound {message}\n    }\n}\n</code></pre> <p>When it finds your super hero, the service could respond with this:</p> <pre><code>{\n  \"data\": {\n    \"find\": {\n      \"__typename\": \"SuperHero\",\n      \"name\": \"Spider-Man\"\n    }\n  }\n}\n</code></pre> <p>Or if it doesn't find it, the response could look like this:</p> <pre><code>{\n  \"data\": {\n    \"find\": {\n      \"__typename\":\"SuperHeroNotFound\",\n      \"message\":\"There is no hero named Foo\"\n    }\n  }\n}\n</code></pre> <p>On the Java side, this maps quite nicely to an interface, e.g. <code>SuperHeroResponse</code> implemented by the two possible classes returned, e.g. <code>SuperHero</code> and <code>SuperHeroNotFound</code>; you only need to provide the typesafe client with this information about these sub-classes by using the <code>JSON-B</code> Polymorphic Types annotations <code>@JsonbTypeInfo</code> and <code>@JsonbSubtype</code>:</p> <pre><code>    @Union\n    @JsonbTypeInfo(key = \"__typename\", value = {\n            @JsonbSubtype(alias = \"SuperHero\", type = SuperHero.class),\n            @JsonbSubtype(alias = \"NotFound\", type = NotFound.class)\n    })\n    public interface SuperHeroResponse {\n    }\n\n    public static class SuperHero implements SuperHeroResponse {\n        String name;\n\n        String getName() {\n            return name;\n        }\n    }\n\n    @Type(\"SuperHeroNotFound\")\n    public static class NotFound implements SuperHeroResponse {\n        String message;\n\n        String getMessage() {\n            return message;\n        }\n    }\n\n    @GraphQLClientApi\n    interface UnionApi {\n        SuperHeroResponse find(String name);\n    }\n</code></pre> <p>Note that we rename the <code>NotFound</code> class into the GraphQL type <code>SuperHeroNotFound</code> to demo that use-case.</p> <p>The <code>@Union</code> annotation is actually not used and only helps to document what's happening behind the scenes.</p>"},{"location":"typesafe-client-unions-and-interfaces/#interfaces","title":"Interfaces","text":"<p>If a service returns an GraphQL <code>interface</code>, that's visible only in the schema; queries and responses work exactly like for a <code>union</code>. So, interfaces are very similar to unions; but they can share common fields between the sub-types.</p> <p>E.g. a query returning either a <code>MainCharacter</code> or a <code>SideKick</code>, could look like this: </p> <pre><code>query find($name: String) {\n    find(name: $name){\n        __typename\n        ... on MainCharacter {name superPower}\n        ... on SideKick {name mainCharacter}\n    }\n}\n</code></pre> <p>The Java side looks very similar the Union example above:</p> <pre><code>@JsonbTypeInfo(key = \"__typename\", value = {\n    @JsonbSubtype(alias = \"MainCharacter\", type = MainCharacter.class),\n    @JsonbSubtype(alias = \"SideKick\", type = SideKick.class)\n})\npublic interface SearchResult {\n    String getName();\n}\n\npublic static class MainCharacter implements SearchResult {\n    String name;\n    String superPower;\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    public String getSuperPower() {\n        return superPower;\n    }\n}\n\npublic static class SideKick implements SearchResult {\n    String name;\n    String mainCharacter;\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    public String getMainCharacter() {\n        return mainCharacter;\n    }\n}\n\n@GraphQLClientApi\ninterface InterfaceApi {\n    SearchResult find(String name);\n\n    List&lt;SearchResult&gt; all();\n}\n</code></pre>"},{"location":"typesafe-client-usage/","title":"Java code-first type-safe GraphQL Client API","text":"<p>A Java code-first type-safe GraphQL Client API suggestion for Microprofile GraphQL Issue #185.</p>"},{"location":"typesafe-client-usage/#basic-usage","title":"Basic Usage","text":"<p>Creating the client-side counterpart of the GraphQL API:</p> <pre><code>package examples.typesafeclient;\n\nimport io.smallrye.graphql.client.typesafe.api.GraphQLClientApi;\n\nimport java.util.List;\n\n@GraphQLClientApi\npublic interface SuperHeroesApi {\n\n    List&lt;SuperHero&gt; allHeroesIn(String location);\n\n}\n</code></pre> <p>A model class:</p> <pre><code>package examples.typesafeclient;\n\nimport java.util.List;\n\npublic class SuperHero {\n\n    private String name;\n    private List&lt;String&gt; superPowers;\n\n    // plus getters and setters\n\n}\n</code></pre> <p>Injecting the client using CDI and using it:</p> <pre><code>package examples.typesafeclient;\n\nimport jakarta.inject.Inject;\nimport java.util.List;\n\npublic class MyClientUsage {\n\n    @Inject\n    SuperHeroesApi superHeroesApi;\n\n    public void execute() {\n        List&lt;SuperHero&gt; allHeroes = superHeroesApi.allHeroesIn(\"Outer Space\");\n        // ...\n    }\n\n}\n</code></pre> <ul> <li>The default request type is <code>query</code>. To make it a mutation, annotate     it <code>@Mutation</code>. The parameter name is only available if you compile     the source with the <code>-parameters</code> option. Otherwise, you\u2019ll have to     annotate all parameters with <code>@Name</code>.</li> </ul> <p>The example above uses CDI, e.g. when you are in a MicroProfile or Jakarta EE environment. If you are in an environment without CDI support, you need to instantiate the API interface by using the builder:</p> <pre><code>SuperHeroesApi api = TypesafeGraphQLClientBuilder.newBuilder().build(SuperHeroesApi.class);\n</code></pre> <p>The basic idea of the Java code-first approach is to start by writing the DTOs and query/mutation methods as you need them in your client. This ensures that you don\u2019t request fields that you don\u2019t need; the thinking is inspired by Consumer Driven Contracts.</p> <p>If the server uses names different from yours, you can use annotations to do a mapping:</p>"},{"location":"typesafe-client-usage/#name-mapping-aliases","title":"Name Mapping / Aliases","text":"<p>If the server defines a different field or parameter name, annotate it with <code>@Name</code>. If the server defines a different query name, annotate the method as, e.g., <code>@Query(\"findHeroesCurrentlyLocatedIn\")</code>.</p> <p>By renaming methods, you can also define several variations of the same request but using different return types or parameters. E.g.:</p> <pre><code>public interface SuperHeroesApi {\n    SuperHero findHeroByName(String name); \n\n    @Query(\"findHeroByName\")\n    SuperHeroWithTeams findHeroWithTeamsByName(String name); \n}\n</code></pre> <ul> <li> <p>The <code>SuperHero</code> class has no team affiliations (for this example).</p> </li> <li> <p>The <code>SuperHeroWithTeams</code> class has a <code>List&lt;Team&gt; teamAffiliations</code>     field. The actual query name is still <code>findHeroByName</code>. The <code>Team</code>     class doesn\u2019t contain the members to break recursion.</p> </li> </ul> <p>If you rename a field or method, the real field or method name will be used as an alias, so you can select the same data twice (see <code>and</code> below).</p>"},{"location":"typesafe-client-usage/#configuration","title":"Configuration","text":"<p>If the endpoint is always the same, e.g. a public API of a cloud service, you can add the URL to your API annotation, e.g.:</p> <pre><code>@GraphQLClientApi(endpoint = \"https://superheroes.org/graphql\")\ninterface SuperHeroesApi {\n}\n</code></pre> <p>When instantiating the API with the builder, you can set (or overwrite) the endpoint there:</p> <pre><code>SuperHeroesApi api = TypesafeGraphQLClientBuilder.newBuilder()\n    .endpoint(\"https://superheroes.org/graphql\")\n    .build(SuperHeroesApi.class);\n</code></pre> <p>Commonly you\u2019ll need different endpoints, e.g. when you need one endpoint for your production system, but a different endpoint for your test system. Simply use MicroProfile Config to set the endpoint; similar to the MicroProfile Rest Client, the key for the endpoint is the fully qualified name of the API interface, plus <code>/mp-graphql/url</code>, e.g.:</p> <pre><code>org.superheroes.SuperHeroesApi/mp-graphql/url=https://superheroes.org/graphql\n</code></pre> <p>If you want to use a different key, set the base config key on the annotation <code>@GraphQLClientApi(configKey = \"superheroes\")</code>; then use this key for the endpoint <code>superheroes/mp-graphql/url</code>.</p> <p>When using the builder, you can override the config key as well: <code>TypesafeGraphQLClientBuilder.newBuilder().configKey(\"superheroes\")</code>.</p>"},{"location":"typesafe-client-usage/#nestedparameter","title":"NestedParameter","text":"<p>Some APIs require parameters beyond the root level, e.g. for filtering or paginating nested lists. Say you have a schema like this:</p> <pre><code>type Query {\n    team(name: String!): Team!\n}\n\ntype Team {\n    members(first: Int!): [SuperHero!]!\n}\n</code></pre> <p>To pass the parameter to the nested field/method, annotate it as <code>@NestedParameter</code>, e.g.:</p> <pre><code>@GraphQLClientApi\ninterface TeamsApi {\n    Team team(String name, @NestedParameter(\"members\") int first);\n}\n</code></pre> <p>The value of the <code>@NestedParameter</code> annotation is the dot-delimited path to the nested field/method that the value should be added to.</p> <p>Example of server code <pre><code>@GraphQLApi\npublic class RoleApi {\n    @Query\n    public List&lt;Role&gt; findAllRolesByUserId(@NonNull UUID userId) {\n        // return roles\n    }\n\n    public List&lt;Permission&gt; permission(@Source Roles role, @DefaultValue(\"5\") int limit) {\n        // return permissions, based on roles\n    }\n\n    public List&lt;PermissionType&gt; permissionType(@Source Permission permission, @DefaultValue(\"5\") int limit) {\n        // return permissionType, based on permission\n    }\n}\n</code></pre></p> <p>Query looks like <pre><code>query {\n  findAllRolesByUserId(userId: ...) {\n    id\n    permission(limit: 2) {\n      id\n      permissionType(limit: 3) {\n        id\n      }\n    }\n  }\n}\n</code></pre></p> <p>On the client side, you can declare the following code: <pre><code>public record PermissionType(Long id) {\n}\n\npublic record Permission(Long id, List&lt;PermissionType&gt; permissionType) {\n}\n\npublic record Role(UUID id, List&lt;Permission&gt; permission) {\n}\n\n@GraphQLClientApi\npublic interface ApiClient {\n    List&lt;Role&gt; findAllRolesByUserId(\n            UUID userId,\n            @NestedParameter(\"permission\") @Name(\"limit\") int permissionLimit,\n            @NestedParameter(\"permission.permissionType\") @Name(\"limit\") int permissionTypeLimit\n    );\n}\n</code></pre></p>"},{"location":"typesafe-client-usage/#namespaces","title":"Namespaces","text":"<p>There are several ways to work with namespaces in a type-safe client: 1. Using <code>@Namespace</code> 2. Using <code>@Name</code> (deprecated)</p> <p>[NOTE] You can only use one of the annotations - <code>@Name</code> or <code>@Namespace</code> on a <code>GraphClientQLApi</code> interface.</p>"},{"location":"typesafe-client-usage/#using-namespace-annotation","title":"Using @Namespace annotation","text":"<p>The <code>@Namespace</code> annotation accepts an array of strings specifying the nesting levels of the namespace. This flexible approach allows you to create namespaces with any desired level of nesting, combining different levels as needed.</p> <p>If the remote GraphQL API has the following schema: <pre><code>\"Query root\"\ntype Query {\n  admin: AdminQuery\n}\n\ntype AdminQuery {\n  users: AdminUsersQuery\n}\n\ntype AdminUsersQuery {\n  findAll: User\n}\n\ntype User {\n  id: BigInteger\n  [...]\n}\n</code></pre></p> <p>While declaring the following interface: <pre><code>@Namespace({\"admin\", \"users\"})\n@GraphQLClientApi\npublic interface UsersClient {\n    List&lt;User&gt; findAll();\n}\n</code></pre></p> <p>Its outcome will be the following GraphQL query: <pre><code>query AminUsersFindAll {\n  admin {\n    users {\n      findAll {\n        id\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"typesafe-client-usage/#using-name-deprecated","title":"Using @Name (deprecated)","text":"<p>[NOTE] This feature may be removed in the future.</p> <p>The <code>@Name</code> annotation functions similarly to <code>@Namespace</code>, but it is limited to a single nesting level. <pre><code>query {\n    users {\n        findAll {\n         ...\n        }\n    }\n}\n</code></pre></p> <pre><code>@Name(\"users\")\n@GraphQLClientApi\npublic interface ApiClient {\n    List&lt;User&gt; findAll();\n}\n</code></pre>"},{"location":"using-smallrye-stork/","title":"Using SmallRye Stork","text":"<p>SmallRye GraphQL client (both dynamic and typesafe) supports SmallRye Stork for  service discovery and load balancing. If your client is configured to connect to a URI with the <code>stork://</code> or <code>storks://</code> scheme, then Stork will be used to determine the actual endpoints to connect to. Load balancing, if configured, will be applied in a way that each HTTP request can be routed to a different service instance. For WebSocket traffic, once a WebSocket connection is established, the client will keep using that connection for as long as possible. If that connection is lost for any reason and needs to be reestablished, then the load balancer can route it to a different instance.</p>"},{"location":"using-smallrye-stork/#using-with-quarkus","title":"Using with Quarkus","text":"<p>The dependency on Stork is declared as optional, so if you want to use it, you might need  to add it explicitly. If you're using Quarkus, use the Stork extension along with  the desired service discovery implementation, for example:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-smallrye-stork&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-stork-service-discovery-static-list&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Example configuration in Quarkus <code>application.properties</code>: <pre><code>quarkus.smallrye-graphql-client.myclient.url=stork://foo-service/graphql\nquarkus.stork.foo-service.service-discovery.type=static\nquarkus.stork.foo-service.service-discovery.address-list=server1.com:8080,server2.com:8080\n</code></pre></p>"},{"location":"using-smallrye-stork/#when-running-as-a-standalone-application","title":"When running as a standalone application","text":"<p>If you're using the client in a standalone mode outside any container that handles Stork initialization for you, you might need two additional steps to get it working:</p> <p>Add a configuration provider for Stork, such as <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-microprofile-config&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></p> <p>And before initializing any GraphQL client instances, make sure that Stork is initialized  by calling <code>io.smallrye.stork.Stork.initialize()</code> once.</p>"}]}